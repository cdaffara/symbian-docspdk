<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="copyright" content="(C) Copyright 2010"/>
<meta name="DC.rights.owner" content="(C) Copyright 2010"/>
<meta name="DC.Type" content="task"/>
<meta name="DC.Title" content="Developing Programs with Task Scheduling Capabilities"/>
<meta name="DC.Relation" scheme="URI" content="GUID-D049392D-2DA4-5E9C-8E3E-FEDF79BC5086.html"/>
<meta name="DC.Relation" scheme="URI" content="index.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-32E29020-1956-461A-B79A-1492E06049E7.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-5072BE46-B1B4-5C3A-BF55-BEA7443E7657.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-94215E49-605B-51BA-B215-10BDA1A0C013.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-D049392D-2DA4-5E9C-8E3E-FEDF79BC5086.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-3CDCE4E0-E29D-5782-8053-B386A9E34BCC.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-00363030-AAE2-5231-8407-AC609DA0F496.html"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94"/>
<meta name="DC.Language" content="en"/>
<link rel="stylesheet" type="text/css" href="commonltr.css"/>
<title>Developing Programs with Task Scheduling Capabilities</title>

     
<link type="text/css" rel="stylesheet" href="css/common.css" media="screen"/>
<link type="text/css" rel="stylesheet" href="css/sdl.css" media="screen"/>

<!--[if IE]>
<link href="css/iefix.css" rel="stylesheet" type="text/css" media="screen" />
<![endif]-->



     <link rel="stylesheet" type="text/css" href="nokiacxxref.css"/></head>
<body id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94"><!-- --></a>


<?php include_once (CURRENT_SKIN_PATH.'/sdl_header.html'); ?>
<div id="sdl_container">
   <div id="leftMenu">  
 <div id="expandcontractdiv">
    <a id="collapseTree" href="javascript:tree.collapseAll()">Collapse all</a>
    <a id="index" href="index.html">Symbian^3 Product Developer Library</a>        
</div>
     <iframe style="border:none" height="800" width="300" src="index-toc.html"></iframe>
<div id="treeDiv1">&#160;</div>
     <script type="text/javascript">
	var currentIconMode = 0; window.name="id2563754 id2381103 id2381979 id2382223 ";
	YAHOO.util.Event.onDOMReady(buildTree, this,true);
    </script>
     
</div>

<div id="sdl_content">


<div class="breadcrumb"><a href="index.html" title="Symbian^3 Product Developer Library">Symbian^3 Product Developer Library</a> &gt; <a href="GUID-32E29020-1956-461A-B79A-1492E06049E7.html" title="The Symbian Guide describes the architecture and functionality of the platform, and provides guides on using its APIs.">Symbian Guide</a> &gt; <a href="GUID-5072BE46-B1B4-5C3A-BF55-BEA7443E7657.html">Generic OS Services Guide</a> &gt; <a href="GUID-94215E49-605B-51BA-B215-10BDA1A0C013.html">Generic Services</a> &gt; <a href="GUID-D049392D-2DA4-5E9C-8E3E-FEDF79BC5086.html">Task Scheduler</a> &gt; </div>
<h1 class="topictitle1">Developing
Programs with Task Scheduling Capabilities</h1>
<div><div><p>Symbian Developers and device creators can use the task scheduler
APIs to develop programs with scheduling capabilities. Programs may need task
scheduling capabilities to support scheduling options that may be required
for a phone user, another program or a system server. </p>
<p>For example,
a phone user can use the alarm option of a clock application to schedule an
alarm to be triggered every day at 5:00 A.M. </p>
</div>

<a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-17AC6716-B2C4-5C14-9764-109D31C3B9DA"><!-- --></a><ol id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-17AC6716-B2C4-5C14-9764-109D31C3B9DA"><li class="stepexpand" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-C6EB0627-BD29-50F5-8A80-2581284DC750"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-C6EB0627-BD29-50F5-8A80-2581284DC750"><!-- --></a><span/><br/>
 Connect the client to the task scheduler server using <a href="GUID-6E138B87-ED51-3C72-9075-8D7F887FA7B1.html#GUID-6E138B87-ED51-3C72-9075-8D7F887FA7B1__GUID-C4EEE075-3B47-3964-AFCC-0CDF09DEDA0F"><span class="apiname">RScheduler::Connect()</span></a>. 
 <pre class="codeblock" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-5D5D73EF-7642-5D91-91EA-09E562F93AE8"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-5D5D73EF-7642-5D91-91EA-09E562F93AE8"><!-- --></a>RScheduler iScheduler;
User::LeaveIfError(iScheduler.Connect());</pre>
 
</li>
<li class="stepexpand" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-F442887C-9F99-50AF-89B3-7B9532E15A8C"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-F442887C-9F99-50AF-89B3-7B9532E15A8C"><!-- --></a><span/><br/>
 Register the client with the task scheduler server using <a href="GUID-6E138B87-ED51-3C72-9075-8D7F887FA7B1.html#GUID-6E138B87-ED51-3C72-9075-8D7F887FA7B1__GUID-C19048C5-DC9F-3B8A-B4AD-02C0D943B7AC"><span class="apiname">RScheduler::Register()</span></a> by
passing the following parameters: 
<a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-B8842174-43F3-5B5D-8906-7699B89A53C8"><!-- --></a><ol type="a" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-B8842174-43F3-5B5D-8906-7699B89A53C8">
<li class="substepexpand" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-E95387B3-CFAA-5523-8105-1999FD5FD309"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-E95387B3-CFAA-5523-8105-1999FD5FD309"><!-- --></a><span/><br/>
 Name and full path of the executable to be used to execute the scheduled
task. For more information about creating this executable, see the <span class="filepath">taskexecutor.cpp</span> topic
in the<a href="GUID-8B938FEF-4D70-4589-921C-C99667193E20.html" title="This example application demonstrates the usage of the Task Scheduler API.">TaskSchedulerExample:
Using Task Scheduler for Creating and Executing Tasks</a> section. 
</li>

<li class="substepexpand" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-A1655664-C67A-5DDD-BF3E-E8DDC98F1FB6"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-A1655664-C67A-5DDD-BF3E-E8DDC98F1FB6"><!-- --></a><span/><br/>
 Priority of the task to be executed, relative to other clients. If two
clients have tasks to execute at the same time, the one with the higher priority
is executed first. 
</li>

</ol>

 The following code snippet illustrates how to register a client with
the task scheduler server: 
 <pre class="codeblock" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-FFF2F47A-10AC-543D-B090-77E6B01A0C62"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-FFF2F47A-10AC-543D-B090-77E6B01A0C62"><!-- --></a>RScheduler iScheduler;
TFileName fileName;
...

//A priority value
const TInt priority = 3;

...

User::LeaveIfError(iScheduler.Register(filename, priority));</pre>
 
 <div class="note"><span class="notetitle">Note:</span> Task scheduler supports only the execution of Symbian platform
executables. The <samp class="codeph">aFileName</samp> parameter can include a path but
must not include a file extension. </div>

 For example, a <samp class="codeph">fileName</samp> can be <span class="filepath">minimalTaskHandler</span>.
Note that in the presence of platform security all EXEs are located in the <span class="filepath">\sys\bin</span> folder
and as a consequence of this, the path of an EXE (only the drive letter) is
not needed. 
</li>
<li class="stepexpand" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-5D132AE0-6A8D-5A56-A52B-2CE8151CC757"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-5D132AE0-6A8D-5A56-A52B-2CE8151CC757"><!-- --></a><span/><br/>
 Create the support for different types of schedules that you want to
provide using the following functions of <a href="GUID-6E138B87-ED51-3C72-9075-8D7F887FA7B1.html"><span class="apiname">RScheduler</span></a>: 
<a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-4F006CFD-2A46-568F-8495-E5B61CBDE4BB"><!-- --></a><ol type="a" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-4F006CFD-2A46-568F-8495-E5B61CBDE4BB">
<li class="substepexpand" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-128E5806-8499-5F19-97ED-F9022046C128"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-128E5806-8499-5F19-97ED-F9022046C128"><!-- --></a><span/><br/>
  <a href="GUID-5CF2FCCF-552B-3BDF-8024-32F895583C8A.html"><span class="apiname">IMPORT_C TInt CreatePersistentSchedule(TSchedulerItemRef&amp;
aRef, const CArrayFixFlat&lt;TScheduleEntryInfo2&gt;&amp; aEntryList)</span></a>:Creates
a persistent time-based schedule without tasks. 
 The following code snippet illustrates how to create a persistent time-based
schedule scheduled to start on January 1st, 2010 at 08:00 A.M., runs every
one hour and is valid for eight hours. 
 <pre class="codeblock" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-E791116D-722C-5F25-BBE5-B4C0DEC5A29A"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-E791116D-722C-5F25-BBE5-B4C0DEC5A29A"><!-- --></a>...

TSchedulerItemRef&amp; aRef;

//Array to hold the schedule entries
CArrayFixFlat&lt;TScheduleEntryInfo2&gt;* cSchEntryInfoArray;    
cSchEntryInfoArray = new CArrayFixFlat&lt;TScheduleEntryInfo2&gt;(1);

CleanupStack::PushL(cSchEntryInfoArray);

// Create an hourly schedule
TScheduleEntryInfo2 entry1;

//Sets the date and time for the schedule as Jan 1st, 2010, 08:00 am
TDateTime datetime2(2010, EJanuary, 1, 8, 0, 0, 0); 
TTsTime time2(datetime2, ETrue);

//Set the first instance when the entry will cause the execution of tasks. 
entry1.SetStartTime(time2);

// Set the interval between execution of tasks
// Here the interval is 2 hours because the interval type is hourly.
const TInt interval = 2;
entry1.SetInterval(interval);

// Set the type of interval used between due times for the scheduled entry
entry1.SetIntervalType(TIntervalType(EHourly));
    
// Set the period for which the entry is valid. After 8 hours the 
// tasks associated with the entry will not be eligible for execution.
const TInt eightHours = 480; // in minutes 
entry1.SetValidityPeriod(TTimeIntervalMinutes(eightHours));
    
cSchEntryInfoArray-&gt;AppendL(entry1);

//create the time-based persistent schedule
User::LeaveIfError(iScheduler.CreatePersistentSchedule(aRef, *cSchEntryInfoArray));

CleanupStack::PopAndDestroy(cSchEntryInfoArray);
...</pre>
 
</li>

<li class="substepexpand" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-FFC11C40-D971-5122-B07C-32695C61EE64"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-FFC11C40-D971-5122-B07C-32695C61EE64"><!-- --></a><span/><br/>
  <a href="GUID-5A30CCBC-8D18-359A-ABB1-E4256ADC7199.html"><span class="apiname">IMPORT_C TInt CreatePersistentSchedule(TSchedulerItemRef&amp;
aRef, const CArrayFixFlat&lt;TTaskSchedulerCondition&gt;&amp; aConditions, const
TTsTime&amp; aDefaultRunTime)</span></a>: Creates a persistent condition-based
schedule without tasks. 
 The following code snippet illustrates how to create a persistent condition-based
schedule that is triggered when both <samp class="codeph">condtion1</samp> and <samp class="codeph">condtion2</samp> are
satisfied. By default, the schedule is set to start on December 10th, 2009
at 09:00 A.M., if the condition set is not met. 
 <pre class="codeblock" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-B1F905E8-DC06-5C94-84FE-7BEC9E21EB43"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-B1F905E8-DC06-5C94-84FE-7BEC9E21EB43"><!-- --></a>...

TSchedulerItemRef&amp; aRef;

//Array to hold the schedule conditions
CArrayFixFlat&lt;TTaskSchedulerCondition&gt;* cTaskScheCondArray;

//Condition list to hold a set of conditions
CSchConditionArray conditionList = new (ELeave) CSchConditionArray(2);
CleanupStack::PushL(conditionList);

//set the first condition
TTaskSchedulerCondition condition1;

//UID of the publish and subscribe category for condition1
const TUid KPubSubsPersistCondCategUid1 = TUid::Uid(0x102F7784);

//Key of the publish and subscribe category for condition2
const TInt KPubSubsPersistCondKey1 = 1;

condition1.iCategory = KPubSubsPersistCondCategUid1;
condition1.iKey        = KPubSubsPersistCondKey1;
condition1.iState    = 10;
condition1.iType    = TTaskSchedulerCondition::EEquals;
conditionList-&gt;AppendL(condition1);

//set the second condition
TTaskSchedulerCondition condition2;

//UID of the publish and subscribe category for condition2
const TUid KPubSubsPersistCondCategUid2 = TUid::Uid(0x103F7784);

//Key of the publish and subscribe category for condition2
const TInt KPubSubsPersistCondKey2 = 1;

condition2.iCategory = KPubSubsPersistCondCategUid2;
condition2.iKey        = KPubSubsPersistCondKey2;
condition2.iState    = 20;
condition2.iType    = TTaskSchedulerCondition::ENotEquals;
conditionList-&gt;AppendL(condition2);

//Set the date and time for the schedule as Dec 10th, 2009, 09:00 am
TDateTime datetime2(2009, EDecember, 10, 9, 0, 0, 0); 
TTsTime time2(datetime2, EFalse);

//create the condition-based persistent schedule
iScheduler.CreatePersistentSchedule(aRef, *conditionList, time2);

CleanupStack::PopAndDestroy(); // conditionList</pre>
 
</li>

<li class="substepexpand" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-E19A594F-F7A8-576F-B509-726FB4DF3B1F"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-E19A594F-F7A8-576F-B509-726FB4DF3B1F"><!-- --></a><span/><br/>
 <a href="GUID-B51E61E7-8A9F-354C-9695-58E741DD21AB.html"><span class="apiname">IMPORT_C TInt ScheduleTask(TTaskInfo&amp; aTaskInfo, HBufC&amp;
aTaskData, TSchedulerItemRef&amp; aRef, const CArrayFixFlat&lt;TScheduleEntryInfo2&gt;&amp;
aEntryList)</span></a>:Creates a transient time-based schedule and adds a task
to it. 
 The following code snippet illustrates how to create a transient time-based
schedule and associate a task to it. It starts at a specific time, runs every
one hour and is valid for two hours. 
 <pre class="codeblock" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-B0087E50-F2F1-5BC8-9165-53C505E53330"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-B0087E50-F2F1-5BC8-9165-53C505E53330"><!-- --></a>...

TSchedulerItemRef ref;

// Array that holds the schedule entries
CArrayFixFlat&lt;TScheduleEntryInfo2&gt;* cSchEntryInfoArray;
cSchEntryInfoArray = new CArrayFixFlat&lt;TScheduleEntryInfo2&gt;(1);

CleanupStack::PushL(cSchEntryInfoArray);

// Create a schedule entry
TScheduleEntryInfo2 entry;

TTime now;

//    Set the date and time of this TTime to the universal time.
now.UniversalTime();
    
// Assign an offset of 15 seconds. 
TInt offset = 15;
now += TTimeIntervalSeconds(offset);

// Constructs a TTsTime with a TTime object.
// ETrue indicates that TTsTime is UTC based time
TTsTime time(now, ETrue);
    
// Set the above time as the first time at which
// the entry will cause execution of tasks. 
entry.SetStartTime(time);
    
// Set the type of interval used between due times for scheduled entry
entry.SetIntervalType(TIntervalType(EHourly));
    
// Set the period for which the entry is valid. 
// After 2 hours the tasks associated with the entry will not be eligible for execution 
TInt validity = 120;
entry.SetValidityPeriod(TTimeIntervalMinutes(validity));
    
// Set the interval between execution of tasks
// Here the interval is 1 hour because the interval type is hourly.
entry.SetInterval(1);

//Add the schedule entry to the array
cSchEntryInfoArray-&gt;AppendL(entry);
    
// Create a transient task to be scheduled
TTaskInfo taskInfo;

// Task id
const TInt tId = 0;
taskInfo.iTaskId = tId;
    
// The task repeats just once
const TInt numberOfRepeats = 1;
taskInfo.iRepeat = numberOfRepeats;
    
// Task priority set by the client. 
// Where a client has two tasks with different priorities, 
// the task with the higher priority will be executed first.
const TInt priority = 2; 
taskInfo.iPriority = priority;
    
_LIT(KScheduleType," transient schedule");
const TDesC* transient = &amp;KScheduleType;
HBufC* data = transient-&gt;AllocLC();
        
// Create the transient time-based schedule 
User::LeaveIfError(iScheduler.ScheduleTask(taskInfo, *data, ref, *cSchEntryInfoArray));

...</pre>
 
  Important:  The task scheduler does not notify a client if a scheduled
task fails to execute successfully. Clients can however use the notification
mechanism of the <a href="GUID-5B63D14D-007D-566F-A065-1A25FE4B97A3.html" title="This section describes the Log Engine.">Log
Engine</a> to get some notification and information of the error condition
that caused the task to fail. 
 <ul>
<li id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-CEB9D7B2-08C1-5256-8E05-743E2F894AFB"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-CEB9D7B2-08C1-5256-8E05-743E2F894AFB"><!-- --></a><p>Errors can occur when
the task scheduler prepares to create and run a task process. The most likely
error is an out of memory error. The task scheduler logs the error to the
system log with type <a href="GUID-3F3A8B98-D750-30C5-A2D5-D28AB1D8EAE9.html"><span class="apiname">KLogTaskSchedulerEventTypeUid</span></a>. The
task or schedule is not retried. </p>
 </li>

<li id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-11D78BC8-02F4-53C3-8544-F5C3F8BD0671"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-11D78BC8-02F4-53C3-8544-F5C3F8BD0671"><!-- --></a><p>If the task process
is created successfully, but it exits with an error, the task scheduler logs
the process exit reason to the system log, also with type <a href="GUID-3F3A8B98-D750-30C5-A2D5-D28AB1D8EAE9.html"><span class="apiname">KLogTaskSchedulerEventTypeUid</span></a>. </p>
 </li>

</ul>
 
</li>

<li class="substepexpand" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-8E8365D3-3A08-5B6E-BA92-73F2E750145C"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-8E8365D3-3A08-5B6E-BA92-73F2E750145C"><!-- --></a><span/><br/>
  <a href="GUID-C6D23376-3EF2-349A-9BCF-812D57E61EA3.html"><span class="apiname">IMPORT_C TInt ScheduleTask(TTaskInfo&amp; aTaskInfo, HBufC&amp;
aTaskData, TSchedulerItemRef&amp; aRef, const CArrayFixFlat&lt;TTaskSchedulerCondition&gt;&amp;
aConditions, const TTsTime&amp; aDefaultRunTime)</span></a>: Creates a transient
condition-based schedule and adds a task to it. 
 The following code snippet illustrates how to create a transient condition-based
schedule and associate a task to it. The schedule is triggered when <samp class="codeph">condition1</samp> is
met. By default, the schedule is set to start on December 10th, 2009 at 09:00
A.M., if the condition set is not met. 
 <pre class="codeblock" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-F1E856BD-38F2-5F65-B1D7-96B11A008F47"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-F1E856BD-38F2-5F65-B1D7-96B11A008F47"><!-- --></a>...

TSchedulerItemRef ref2;

//Array that holds the conditions
CArrayFixFlat&lt;TTaskSchedulerCondition&gt;* CSchConditionArray;
CSchConditionArray conditionList = new (ELeave) CSchConditionArray(1);

CleanupStack::PushL(conditionList);

//set the condition
TTaskSchedulerCondition condition1;

//UID of the publish and subscribe category for condition1
const TUid KPubSubsTransCondCategUid1 = TUid::Uid(0x102F7785);

//Key of the publish and subscribe category for condition1
const TInt KPubSubsTransCondKey1 = 1;

condition1.iCategory = KPubSubsTransCondCategUid1;
condition1.iKey        = KPubSubsTransCondKey1;
condition1.iState    = 10;
condition1.iType    = TTaskSchedulerCondition::EEquals;
conditionList-&gt;AppendL(condition1);

// Associate a task with the condition-based schedule
TTaskInfo taskInfo2;

_LIT(KTransSchedTaskName, "Transient - Condition-Based");
_LIT(KTransSchedTaskData2, "Task data for transient schedule");

taskInfo2.iName = KTransSchedTaskName;
taskInfo2.iPriority = 2;
taskInfo2.iRepeat = 0;

// Create some data associated with this task
HBufC* taskTransSchedData = KTransSchedTaskData2().AllocLC();

//set the default time at which you want the transient condition-based
//schedule to start, if no conditions are met
// sets the date and time as Jan 1st, 2010, 10:01 am
TDateTime datetime2(2010, EJanuary, 1, 10, 1, 0, 0); 
TTsTime defaultRuntime(datetime2, ETrue); // 10:01 am

// Create the transient condition-based schedule
User::LeaveIfError(iScheduler.ScheduleTask(taskInfo2, *taskTransSchedData, ref2, *conditionList, defaultRuntime));

CleanupStack::PopAndDestroy(2); // taskTransSchedData, conditionList

...</pre>
 
</li>

</ol>

 <div class="note"><span class="notetitle">Note:</span>  Schedules can be either persistent or transient. Persistent schedules
have schedule information and any corresponding task data persisted to the
disk. </div>

 The task scheduler server reads this data back into memory when the
phone is restarted. But, transient schedules do not have their data persisted
and are deleted automatically once any associated tasks have finished running. 
</li>
<li class="stepexpand" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-265E13BF-EC53-5308-ABD1-92FAF2F3A9E0"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-265E13BF-EC53-5308-ABD1-92FAF2F3A9E0"><!-- --></a><span/><br/>
 Create the support for adding tasks to a persistent schedule by passing
the handle of the persistent schedule to <a href="GUID-A293C22A-B2A7-333B-B2B7-E28A22343DE9.html"><span class="apiname">ScheduleTask(TTaskInfo&amp;
aTaskInfo, HBufC&amp; aTaskData, const TInt aScheduleHandle)</span></a>. 
 <strong> Notes</strong>:  <ul>
<li><p>This step applies only, if you have already created a persistent schedule. </p>
</li>

<li><p>For more information about the effects of backup and restore on scheduled
tasks in persistent schedules, see the <a href="GUID-00363030-AAE2-5231-8407-AC609DA0F496.html">Backup
and Restore on Scheduled Tasks in Persistent Schedules</a>. </p>
</li>

</ul>
<p/>

 The following code snippet illustrates how to create a task and associate
it with an existing persistent schedule. 
 <pre class="codeblock" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-BA89C9FD-0876-59CE-BD90-BBEE3526277F"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-BA89C9FD-0876-59CE-BD90-BBEE3526277F"><!-- --></a>
...

//Contains the handle to the persistent schedule
TInt aScheduleId;
...


TInt&amp; aNewId;

//Create the task that you want to add the persistent schedule
TTaskInfo taskInfo;
taskInfo.iTaskId = aNewId;

_LIT(aName, "Task for Persistent Schedule");

taskInfo.iName = aName;
taskInfo.iPriority = 2;
taskInfo.iRepeat = 0;

HBufC* taskdata = _L("the data").AllocLC();

iScheduler.ScheduleTask(taskInfo, *taskdata, aScheduleId);

//Update aNewId with the task ID set by the task scheduler
aNewId = taskInfo.iTaskId;
...

CleanupStack::PopAndDestroy(); // taskdata

...</pre>
 
  Notes:  
 <div class="p"><ul>
<li><p>The <samp class="codeph">HBufC* taskdata</samp> parameter is used by clients who
want to send data to the executable that is launched when the task becomes
due. When the executable is launched, this data is stored in a temporary task
file and the filename is passed on the command line to the newly created process.
That executable can then open the file and stream in the contents. </p>
</li>

<li><p>If multiple tasks are assigned to a schedule that has become due, the
data for each schedule is concatenated into the same file. The tasks are stored
in the file as <a href="GUID-049FF2D7-8444-3E87-BF2F-DD0EA9B10ED0.html"><span class="apiname">CScheduledTask</span></a> instances. The first item
in the file is an integer describing how many tasks there are in the file.
Subsequently the file just contains tasks which can be streamed in using the <a href="GUID-049FF2D7-8444-3E87-BF2F-DD0EA9B10ED0.html#GUID-049FF2D7-8444-3E87-BF2F-DD0EA9B10ED0__GUID-F9ED1FDD-0DAF-3450-99A6-730D43D00FE0"><span class="apiname">CScheduledTask::NewLC()</span></a> method. </p>
</li>

</ul>
</div>

</li>
<li class="stepexpand" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-DEE8E40C-ED35-5C48-9406-DA44B1E68A61"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-DEE8E40C-ED35-5C48-9406-DA44B1E68A61"><!-- --></a><span/><br/>
 Create the support for viewing schedules. This involves two steps: 
<a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-97888525-CEB8-530F-A092-5DB980E7C841"><!-- --></a><ol type="a" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-97888525-CEB8-530F-A092-5DB980E7C841">
<li class="substepexpand" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-B783CD9D-AE70-5BB9-B6ED-CC93EEE97512"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-B783CD9D-AE70-5BB9-B6ED-CC93EEE97512"><!-- --></a><span/><br/>
 Get the name and ID (schedule handle) of schedules using <a href="GUID-6E138B87-ED51-3C72-9075-8D7F887FA7B1.html#GUID-6E138B87-ED51-3C72-9075-8D7F887FA7B1__GUID-7C8B221C-F8E5-3EEE-9693-2055D6F1EBF4"><span class="apiname">RScheduler::GetScheduleRefsL()</span></a>. 
 <pre class="codeblock" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-07058B0D-CD00-53A0-B744-6073FD81B941"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-07058B0D-CD00-53A0-B744-6073FD81B941"><!-- --></a>//Array that holds schedule entries
CArrayFixFlat&lt;TSchedulerItemRef&gt;* CSchItemRefArray;
CSchItemRefArray = new CArrayFixFlat&lt;TSchedulerItemRef&gt;(3);

CleanupStack::PushL(CSchItemRefArray);

//Get the list of all schedules
User::LeaveIfError(iScheduler.GetScheduleRefsL(*CSchItemRefArray, EAllSchedules));

...

//Gets the schedule handle and assigns it to schedHandle
TInt schedHandle = *CSchItemRefArray)[1].iHandle;

...</pre>
 
</li>

<li class="substepexpand" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-5D034701-EF62-5982-8070-A2C40DDD1122"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-5D034701-EF62-5982-8070-A2C40DDD1122"><!-- --></a><span/><br/>
 Get schedule details by passing the schedule handle to <a href="GUID-6E138B87-ED51-3C72-9075-8D7F887FA7B1.html#GUID-6E138B87-ED51-3C72-9075-8D7F887FA7B1__GUID-AD5F8784-D619-32BB-B125-30C7393FA1A9"><span class="apiname">RScheduler::GetScheduleL()</span></a> or <a href="GUID-6E138B87-ED51-3C72-9075-8D7F887FA7B1.html#GUID-6E138B87-ED51-3C72-9075-8D7F887FA7B1__GUID-946F7B2F-EF2C-33DB-A397-D31A009165A6"><span class="apiname">RScheduler::GetScheduleTypeL()</span></a>. 
 <ul>
<li id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-D15FBE3E-4214-5074-A91C-747324339C7E"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-D15FBE3E-4214-5074-A91C-747324339C7E"><!-- --></a><p> <strong>Viewing details
of time-based schedules:</strong>  </p>
 <pre class="codeblock" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-27955B2E-A6F6-5D13-8AFD-7AC37F579E31"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-27955B2E-A6F6-5D13-8AFD-7AC37F579E31"><!-- --></a>...

CArrayFixFlat&lt;TTaskInfo&gt; CTaskInfoArray;
CTaskInfoArray* tasks = new (ELeave) CTaskInfoArray(3);

TTsTime nextTimeScheduleIsDue;
TScheduleState2 stateTimebasedSched;

CArrayFixFlat&lt;TScheduleEntryInfo2&gt; CScheduleEntryInfoArray;
CScheduleEntryInfoArray* entries = new (ELeave) CScheduleEntryInfoArray(3);

CleanupStack::PushL(entries);

iScheduler.GetScheduleL(schedHandle, stateTimebasedSched, *entries, tasks, nextTimeScheduleIsDue);
CleanupStack::PopAndDestroy(entries);</pre>
 </li>

<li id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-5EBF8371-0DAB-5C02-93BE-84C75D2258A3"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-5EBF8371-0DAB-5C02-93BE-84C75D2258A3"><!-- --></a><p> <strong>Viewing details
of condition-based schedules:</strong>  </p>
 <pre class="codeblock" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-240EF5BE-211F-5CA4-AD03-0A39B7FD9927"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-240EF5BE-211F-5CA4-AD03-0A39B7FD9927"><!-- --></a>...

TTsTime defaultTime;
TScheduleState2 state;

CArrayFixFlat&lt;TTaskInfo&gt; CTaskInfoArray;
CTaskInfoArray* tasks = new (ELeave) CTaskInfoArray(3);

CArrayFixFlat&lt;TTaskSchedulerCondition&gt; CSchConditionArray;
CSchConditionArray* conditionList = new (ELeave) CSchConditionArray(3);
CleanupStack::PushL(conditionList);

iScheduler.GetScheduleL(schedHandle, state, *conditionList, defaultTime, tasks);

CleanupStack::PopAndDestroy(conditionList);</pre>
 </li>

<li id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-9966127B-4650-510D-9FD4-36177F801889"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-9966127B-4650-510D-9FD4-36177F801889"><!-- --></a><p> <strong>Viewing the schedule
type associated with a schedule:</strong> Identifies whether the schedule is a
condition or time-based. </p>
 <pre class="codeblock" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-E696A2CA-3135-56BD-8B41-AE2CB5E6FDC0"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-E696A2CA-3135-56BD-8B41-AE2CB5E6FDC0"><!-- --></a>...

TScheduleType &amp;type;

iScheduler.GetScheduleTypeL(schedHandle, type);</pre>
 </li>

</ul>
 
</li>

</ol>

</li>
<li class="stepexpand" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-BA59B4AB-0104-5794-808E-5D9F6693BE03"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-BA59B4AB-0104-5794-808E-5D9F6693BE03"><!-- --></a><span/><br/>
 Create the support for editing, enabling and disabling schedules. Schedules
can be edited using <a href="GUID-6E138B87-ED51-3C72-9075-8D7F887FA7B1.html#GUID-6E138B87-ED51-3C72-9075-8D7F887FA7B1__GUID-50B287A9-F62F-3C49-AD22-2760C96846EA"><span class="apiname">RScheduler::EditSchedule()</span></a> when a change
is required to be done to a schedule. 
 Before making changes to a schedule, you can use <a href="GUID-6E138B87-ED51-3C72-9075-8D7F887FA7B1.html#GUID-6E138B87-ED51-3C72-9075-8D7F887FA7B1__GUID-64263B93-74B9-3526-B585-4B2E8B8B86A2"><span class="apiname">RScheduler::DisableSchedule()</span></a> to
disable a schedule, so that it is not triggered and later use <a href="GUID-6E138B87-ED51-3C72-9075-8D7F887FA7B1.html#GUID-6E138B87-ED51-3C72-9075-8D7F887FA7B1__GUID-5AE06AE8-46BA-3339-8ADB-E7C642928C9C"><span class="apiname">RScheduler::EnableSchedule()</span></a> to
enable it, once the changes are done to the schedule. 
 The following code snippet illustrates how to disable a time-based schedule,
edit it to make changes to the schedule and later enable the schedule. 
 <pre class="codeblock" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-BD180A79-767B-54A4-A5EA-4D763A295D4C"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-BD180A79-767B-54A4-A5EA-4D763A295D4C"><!-- --></a>//Editing time-based schedules
                  
...

TInt schedHandle;

...

//Disables the schedule referenced by "schedHandle"
User::LeaveIfError(iScheduler.DisableSchedule(schedHandle);
...

//Array to hold the schedule entries
CArrayFixFlat&lt;TScheduleEntryInfo2&gt; CSchEntryInfoArray;
CSchEntryInfoArray* entryList = new (ELeave) CSchEntryInfoArray(3);

CleanupStack::PushL(entryList);

//Change the start date and time as Jan 10th, 2010, 11:00 am
TDateTime datetime2(2010, EJanuary, 10, 11, 0, 0, 0);
TTsTime defaultRuntime(datetime2, ETrue);

//create the schedule entry with the updated time
TScheduleEntryInfo2 entry1 (defaultRuntime, EDaily, 1, 20); // 20m from "now"
entryList-&gt;AppendL(entry1);

//Enables the schedule referenced by "schedHandle"
User::LeaveIfError(iScheduler.EnableSchedule(schedHandle);

//edit the schedule
User::LeaveIfError(iScheduler.EditSchedule(schedHandle, entryList));
        
CleanupStack::PopAndDestroy(entryList);</pre>
 
 The following code snippet illustrates how to edit a condition-based
schedule by passing the schedule handle of the schedule to be edited and the
updated schedule condition details to <a href="GUID-6E138B87-ED51-3C72-9075-8D7F887FA7B1.html#GUID-6E138B87-ED51-3C72-9075-8D7F887FA7B1__GUID-50B287A9-F62F-3C49-AD22-2760C96846EA"><span class="apiname">RScheduler::EditSchedule()</span></a>. 
 <pre class="codeblock" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-35B0F192-2530-5BD4-8AF5-E44C02405D13"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-35B0F192-2530-5BD4-8AF5-E44C02405D13"><!-- --></a>//Editing condition-based schedules
...

TInt schedHandle;

...

CArrayFixFlat&lt;TTaskSchedulerCondition&gt;* CSchConditionArray;


CSchConditionArray conditionList = new (ELeave) CSchConditionArray(2);
CleanupStack::PushL(conditionList);

//update the condition
TTaskSchedulerCondition condition1;

//UID of the publish and subscribe category for condition1
const TUid KPubSubsTransCondCategUid1 = TUid::Uid(0x102F7785);

//Key of the publish and subscribe category for condition1
const TInt KPubSubsTransCondKey1 = 1;

condition1.iCategory = KPubSubsTransCondCategUid1;
condition1.iKey        = KPubSubsTransCondKey1;
condition1.iState    = 10;
condition1.iType    = TTaskSchedulerCondition::EEquals;
conditionList-&gt;AppendL(condition1);

// sets the date and time as Jan 10th, 2010, 10:00 am
TDateTime datetime2(2010, EJanuary, 10, 10, 0, 0, 0);
TTsTime defaultRuntime(datetime2, ETrue);

iScheduler.EditSchedule(schedHandle, *conditionList, defaultRuntime);

...</pre>
 
</li>
<li class="stepexpand" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-91C5C26A-7120-500C-8F42-AE61133BB375"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-91C5C26A-7120-500C-8F42-AE61133BB375"><!-- --></a><span/><br/>
 Create the support for deleting schedules using <a href="GUID-6E138B87-ED51-3C72-9075-8D7F887FA7B1.html#GUID-6E138B87-ED51-3C72-9075-8D7F887FA7B1__GUID-B4CECD92-82C6-3CEC-8DA6-E4D1580BEC00"><span class="apiname">RScheduler::DeleteSchedule()</span></a>. 
 <pre class="codeblock" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-DBB6A497-BFFC-5832-B5E8-5B8D2F713576"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-DBB6A497-BFFC-5832-B5E8-5B8D2F713576"><!-- --></a>...

//Deletes the schedule referenced by "schedHandle"
iScheduler.DeleteSchedule(schedHandle);</pre>
 
</li>
<li class="stepexpand" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-83E497A5-9C7C-5B57-A4E1-922A0B9BF913"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-83E497A5-9C7C-5B57-A4E1-922A0B9BF913"><!-- --></a><span/><br/>
 Create the support for viewing task information associated with a schedule.
This involves two steps: 
<a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-F7C63AE4-4F06-58A6-9614-BC5356176977"><!-- --></a><ol type="a" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-F7C63AE4-4F06-58A6-9614-BC5356176977">
<li class="substepexpand" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-89600927-D804-54C6-8C97-459BD3C1078E"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-89600927-D804-54C6-8C97-459BD3C1078E"><!-- --></a><span/><br/>
 Get a list of all tasks or a subset of tasks using <a href="GUID-6E138B87-ED51-3C72-9075-8D7F887FA7B1.html#GUID-6E138B87-ED51-3C72-9075-8D7F887FA7B1__GUID-8A56C5D7-473C-3CA1-9B03-E6C794434EAB"><span class="apiname">RScheduler::GetTaskRefsL()</span></a>. 
 <pre class="codeblock" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-6EA170CE-2CE5-5E43-B9AA-3FC177BF1B3F"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-6EA170CE-2CE5-5E43-B9AA-3FC177BF1B3F"><!-- --></a>//Array to hold the list of tasks
CArrayFixFlat&lt;TSchedulerItemRef&gt; CSchItemRefArray;
CSchItemRefArray* refs = new (ELeave) CSchItemRefArray(3);

//Gets the list of tasks
iScheduler.GetTaskRefsL(*refs, EAllSchedules, EAllTasks);

CleanupStack::PopAndDestroy(refs);</pre>
 
</li>

<li class="substepexpand" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-242AEAF8-CC8B-5EA3-9394-A62F79275735"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-242AEAF8-CC8B-5EA3-9394-A62F79275735"><!-- --></a><span/><br/>
 Get details associated with a specific task using <a href="GUID-6E138B87-ED51-3C72-9075-8D7F887FA7B1.html#GUID-6E138B87-ED51-3C72-9075-8D7F887FA7B1__GUID-389F77C6-6127-3376-B4CF-993A5849903B"><span class="apiname">RScheduler::GetTaskInfoL()</span></a>. 
 <pre class="codeblock" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-8EB737CE-5990-5A04-8A44-CA1B3EDB82DE"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-8EB737CE-5990-5A04-8A44-CA1B3EDB82DE"><!-- --></a>...

//Handle to the task
TInt aTaskHandle;

...

TInt taskSize = 0;

//Gets the size of the data to be passed to the task's program.
taskSize = iScheduler.GetTaskDataSize(aTaskHandle, taskSize);
HBufC* taskData = HBufC::NewLC(taskSize);

TPtr pTaskData = taskData-&gt;Des();

TTsime scheduleNextDueTime;
TTaskInfo taskFromServer;
TSchedulerItemRef scheduleReference;

//Gets task details
iScheduler.GetTaskInfoL(aTaskHandle, taskFromServer, pTaskData, scheduleReference, scheduleNextDueTime);

CleanupStack::PopAndDestroy(taskData);</pre>
 
</li>

</ol>

</li>
<li class="stepexpand" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-85E5D82C-B280-57D3-89E2-7AC8C63C072C"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-85E5D82C-B280-57D3-89E2-7AC8C63C072C"><!-- --></a><span/><br/>
 Create the support for deleting tasks associated with a schedule using <a href="GUID-6E138B87-ED51-3C72-9075-8D7F887FA7B1.html#GUID-6E138B87-ED51-3C72-9075-8D7F887FA7B1__GUID-BE934053-79EA-3101-899D-18BC91359BB7"><span class="apiname">RScheduler::DeleteTask()</span></a>. 
 <pre class="codeblock" id="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-ADF28359-38D9-5B32-8828-929E4AE56496"><a name="GUID-74C1C345-823C-5CD5-8FC5-214A55734E94__GUID-ADF28359-38D9-5B32-8828-929E4AE56496"><!-- --></a>TInt taskId;

...

iScheduler.DeleteTask(taskId);</pre>
 
</li>
</ol>

</div>
<div>
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a href="GUID-D049392D-2DA4-5E9C-8E3E-FEDF79BC5086.html">Task Scheduler</a></div>
</div>
<div class="relinfo relconcepts"><strong>Related concepts</strong><br/>
<div><a href="GUID-3CDCE4E0-E29D-5782-8053-B386A9E34BCC.html">Task Scheduler
Overview</a></div>
<div><a href="GUID-00363030-AAE2-5231-8407-AC609DA0F496.html">Backup and
Restore on Scheduled Tasks in Persistent Schedules</a></div>
</div>
</div>   
<p class="copyright">Copyright &#169;2010 Nokia Corporation and/or its subsidiary(-ies).<br /> All rights
reserved. Unless otherwise stated, these materials are provided under the terms of the <a href=" http://www.eclipse.org/legal/epl-v10.html"> Eclipse Public License
v1.0</a>.</p> 
</div>
</div>
<?php include_once (CURRENT_SKIN_PATH.'/sdl_footer.html'); ?>

</body>
</html>