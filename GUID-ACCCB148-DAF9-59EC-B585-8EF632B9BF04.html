<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="copyright" content="(C) Copyright 2010"/>
<meta name="DC.rights.owner" content="(C) Copyright 2010"/>
<meta name="DC.Type" content="concept"/>
<meta name="DC.Title" content="SQL Joins"/>
<meta name="abstract" content="This guide explains how to use CROSS JOIN phrases to override the optimizer's ordering of tables."/>
<meta name="description" content="This guide explains how to use CROSS JOIN phrases to override the optimizer's ordering of tables."/>
<meta name="DC.Relation" scheme="URI" content="GUID-831F9AA3-0209-53DC-96C4-04157F22870C.html"/>
<meta name="DC.Relation" scheme="URI" content="index.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-32E29020-1956-461A-B79A-1492E06049E7.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-FBCBF8A0-7922-5881-A1C5-5DB41630E75A.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-F8824165-4B33-50D1-9706-BD2438B5A2EE.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-868D5B32-1CC4-506E-9C49-C86428B9A50F.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-C6D3827F-8F73-593E-A339-B510EEB9771F.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-831F9AA3-0209-53DC-96C4-04157F22870C.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-22844C28-AB5B-5A6F-8863-7269464684B4.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-78773BCA-ADF6-53E6-AC80-5CB2AE1F8BCC.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-1F12E3F5-45B2-55EC-B021-00338277C608.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-43CA02E7-0101-5824-B91B-E15EE20C829A.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-49A3419F-D20A-5C5D-B2FF-51724EF37704.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-C2FAEBB2-4A1A-5BB0-9670-4801525CBC6A.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-B994E6F7-228A-5433-B87F-91857C5D93D6.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-4FC23DB7-4758-5DA4-81FF-0DAB169E2757.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-2A2920E0-5D40-5358-BC0C-8572CEFE078C.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-126FCCCC-0E7D-59AE-959A-2F94A7319C4B.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-B7E978C1-45CA-554C-8028-D901B97BA2E0.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-AF5A75D7-0687-546C-87B2-0B7DF7D33217.html"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="GUID-ACCCB148-DAF9-59EC-B585-8EF632B9BF04"/>
<meta name="DC.Language" content="en"/>
<link rel="stylesheet" type="text/css" href="commonltr.css"/>
<title>SQL Joins</title>

     
<link type="text/css" rel="stylesheet" href="css/common.css" media="screen"/>
<link type="text/css" rel="stylesheet" href="css/sdl.css" media="screen"/>

<!--[if IE]>
<link href="css/iefix.css" rel="stylesheet" type="text/css" media="screen" />
<![endif]-->



     <link rel="stylesheet" type="text/css" href="nokiacxxref.css"/></head>
<body id="GUID-ACCCB148-DAF9-59EC-B585-8EF632B9BF04"><a name="GUID-ACCCB148-DAF9-59EC-B585-8EF632B9BF04"><!-- --></a>


<?php include_once (CURRENT_SKIN_PATH.'/sdl_header.html'); ?>
<div id="sdl_container">
   <div id="leftMenu">  
 <div id="expandcontractdiv">
    <a id="collapseTree" href="javascript:tree.collapseAll()">Collapse all</a>
    <a id="index" href="index.html">Symbian^3 Product Developer Library</a>        
</div>
     <iframe style="border:none" height="800" width="300" src="index-toc.html"></iframe>
<div id="treeDiv1">&#160;</div>
     <script type="text/javascript">
	var currentIconMode = 0; window.name="id2563754 id2859821 id2860178 id2534422 id2534459 id2534479 ";
	YAHOO.util.Event.onDOMReady(buildTree, this,true);
    </script>
     
</div>

<div id="sdl_content">


<div class="breadcrumb"><a href="index.html" title="Symbian^3 Product Developer Library">Symbian^3 Product Developer Library</a> &gt; <a href="GUID-32E29020-1956-461A-B79A-1492E06049E7.html" title="The Symbian Guide describes the architecture and functionality of the platform, and provides guides on using its APIs.">Symbian Guide</a> &gt; <a href="GUID-FBCBF8A0-7922-5881-A1C5-5DB41630E75A.html" title="Provides services to enable and support persistence.">Persistent Data Services Guide</a> &gt; <a href="GUID-F8824165-4B33-50D1-9706-BD2438B5A2EE.html" title="The persistent storage collection.">Persistent Storage</a> &gt; <a href="GUID-868D5B32-1CC4-506E-9C49-C86428B9A50F.html" title="The Symbian SQL component.">Symbian SQL</a> &gt; <a href="GUID-C6D3827F-8F73-593E-A339-B510EEB9771F.html">SQL Concept Guides</a> &gt; <a href="GUID-831F9AA3-0209-53DC-96C4-04157F22870C.html" title="This topic discusses tips for SQL developers.">SQL Developer Tips</a> &gt; </div>
<h1 class="topictitle1">SQL Joins</h1>
<div><p>This guide explains how to use CROSS JOIN phrases to override the
optimizer's ordering of tables.</p>

<div class="section" id="GUID-ACCCB148-DAF9-59EC-B585-8EF632B9BF04__GUID-C6BDCE52-468D-459F-980C-A9041B56BDF1"><a name="GUID-ACCCB148-DAF9-59EC-B585-8EF632B9BF04__GUID-C6BDCE52-468D-459F-980C-A9041B56BDF1"><!-- --></a><h2 class="sectiontitle">Introduction</h2> <p>SQLite uses the “CROSS JOIN” phrase
as a means to override the table reordering decisions of the query optimizer.
The CROSS JOIN connector is rarely needed and should probably never be used
prior to the final performance tuning phase of application development. Even
then, SQLite usually gets the order of tables in a join right without any
extra help. But on those rare occasions when SQLite gets it wrong, the CROSS
JOIN connector is an invaluable way of tweaking the optimizer to do what you
want. </p>
 <p><strong>Intended
audience:</strong> </p>
 <p>This document is intended to be used by Symbian platform
licensees and third party application developers. </p>
 </div>

<div class="section" id="GUID-ACCCB148-DAF9-59EC-B585-8EF632B9BF04__GUID-8B5F579E-B94D-527C-9530-367B5B0729C9"><a name="GUID-ACCCB148-DAF9-59EC-B585-8EF632B9BF04__GUID-8B5F579E-B94D-527C-9530-367B5B0729C9"><!-- --></a><h2 class="sectiontitle">Use CROSS JOIN
to Force a Particular Join Ordering</h2> <p>The SQLite query optimizer
will attempt to reorder the tables in a join in order to find the most efficient
way to evaluate the join. The optimizer usually does this job well, but occasionally
it will make a bad choice. When that happens, it might be necessary to override
the optimizer's choice by explicitly specifying the order of tables in the
SELECT statement. </p>
 <p>To illustrate the problem, consider the following
schema: </p>
 <pre class="codeblock" id="GUID-ACCCB148-DAF9-59EC-B585-8EF632B9BF04__GUID-8B2D4E3C-7231-5D63-B8CD-CD687750CD1E"><a name="GUID-ACCCB148-DAF9-59EC-B585-8EF632B9BF04__GUID-8B2D4E3C-7231-5D63-B8CD-CD687750CD1E"><!-- --></a>
CREATE TABLE node(
    id INTEGER PRIMARY KEY,
    name TEXT
);

CREATE INDEX node_idx ON node(name);

CREATE TABLE edge(
    orig INTEGER REFERENCES node,
    dest INTEGER REFERENCES node,
    PRIMARY KEY(orig, dest)
);

CREATE INDEX edge_idx ON edge(dest,orig);
</pre>
 <p>This schema defines a directed graph with the ability to store
a name on each node of the graph. Similar designs (though usually more complicated)
arise frequently in application development. Now consider a three-way join
against the above schema: </p>
 <pre class="codeblock" id="GUID-ACCCB148-DAF9-59EC-B585-8EF632B9BF04__GUID-61383F86-E84F-58F4-B2B1-81CD25635B88"><a name="GUID-ACCCB148-DAF9-59EC-B585-8EF632B9BF04__GUID-61383F86-E84F-58F4-B2B1-81CD25635B88"><!-- --></a>
SELECT e.*
FROM edge AS e,
 node AS n1,
 node AS n2
WHERE n1.name = 'alice'
 AND n2.name = 'bob'
 AND e.orig = n1.id
 AND e.dest = n2.id;
</pre>
 <p>This query asks for information about all edges that go from
nodes labelled “alice” over to nodes labelled “bob”. </p>
 <p>There are many
ways that the optimizer might choose to implement this query, but they all
boil down to two basic designs. The first option looks for edges between all
pairs of nodes. The following pseudocode illustrates: </p>
 <pre class="codeblock" id="GUID-ACCCB148-DAF9-59EC-B585-8EF632B9BF04__GUID-19A9F537-D791-5894-9FA9-E205B3768CF7"><a name="GUID-ACCCB148-DAF9-59EC-B585-8EF632B9BF04__GUID-19A9F537-D791-5894-9FA9-E205B3768CF7"><!-- --></a>
foreach n1 where n1.name='alice' do:
    foreach n2 where n2.name='bob' do:
        foreach e where e.orig=n1.id and e.dest=n2.id do:
            return e.*
        end
    end
end
</pre>
 <p>The second design is to loop over all 'alice' nodes and follow
edges off of those nodes looking for nodes named 'bob'. (The roles of 'alice'
and 'bob' might be reversed here without changing the fundamental character
or the algorithm): </p>
 <pre class="codeblock" id="GUID-ACCCB148-DAF9-59EC-B585-8EF632B9BF04__GUID-02A72F7B-D5AB-5306-95F9-9832EF05FB25"><a name="GUID-ACCCB148-DAF9-59EC-B585-8EF632B9BF04__GUID-02A72F7B-D5AB-5306-95F9-9832EF05FB25"><!-- --></a>
foreach n1 where n1.name='alice' do:
    foreach e where e.orig=n1.id do:
        foreach n2 where n2.id=e.dest and n2.name='bob' do:
            return e.*
        end
    end
end
</pre>
 <p>The first algorithm above corresponds to a join order of n1-n2-e.
The second algorithm corresponds to a join order of n1-e-n2. </p>
 <p>The question
the optimizer has to answer is which of these two algorithms is likely to
give the fastest result, and it turns out that the answer depends on the nature
of the data stored in the database. </p>
 <p>Let the number of alice nodes
be M and the number of bob nodes be N. Consider two scenarios: In the first
scenario, M and N are both 2 but there are thousands of edges on each node.
In this case, the first algorithm is preferred. With the first algorithm,
the inner loop checks for the existence of an edge between a pair of nodes
and outputs the result if found. But because there are only 2 alice and bob
nodes each, the inner loop only has to run 4 times and the query is very quick. </p>
 <p>The
second algorithm would take much longer here. The outer loop of the second
algorithm only executes twice, but because there are a large number of edges
leaving each 'alice' node, the middle loop has to iterate many thousands of
times. So in the first scenario, we prefer to use the first algorithm. </p>
 <p>Now
consider the case where M and N are both 3500. But suppose each of these nodes
is connected by only one or two edges. In this case, the second algorithm
is preferred. </p>
 <p>With the second algorithm, the outer loop still has
to run 3500 times, but the middle loop only runs once or twice for each outer
loop and the inner loop will only run once for each middle loop, if at all.
So the total number of iterations of the inner loop is around 7000. </p>
 <p>The
first algorithm, on the other hand, has to run both its outer loop and its
middle loop 3500 times each, resulting in 12 million iterations of the middle
loop. Thus in the second scenario, second algorithm is nearly 2000 times faster
than the first. </p>
 <p>In this particular example, if you run ANALYZE on
your database to collect statistics on the tables, the optimizer will be able
to figure out the best algorithm to use. But if you do not want to run ANALYZE
or if you do not want to waste database space storing the SQLITE_STAT1 statistics
table that ANALYZE generates, you can manually override the decision of the
optimizer by specifying a particular order for tables in a join. You do this
by substituting the keyword phrase “CROSS JOIN” in place of commas in the
FROM clause. </p>
 <p>The “CROSS JOIN” phrase forces the table to the left
to be used before the table to the right. For example, to force the first
algorithm, write the query this way: </p>
 <pre class="codeblock" id="GUID-ACCCB148-DAF9-59EC-B585-8EF632B9BF04__GUID-E0FE82CE-0D32-535F-A4F7-EF582BFA7AE9"><a name="GUID-ACCCB148-DAF9-59EC-B585-8EF632B9BF04__GUID-E0FE82CE-0D32-535F-A4F7-EF582BFA7AE9"><!-- --></a>
SELECT *
FROM node AS n1 CROSS JOIN
 node AS n2 CROSS JOIN
 edge AS e
WHERE n1.name = 'alice'
 AND n2.name = 'bob'
 AND e.orig = n1.id
 AND e.dest = n2.id;
</pre>
 <p>And to force the second algorithm, write the query like this: </p>
 <pre class="codeblock" id="GUID-ACCCB148-DAF9-59EC-B585-8EF632B9BF04__GUID-33AD25F2-E58E-5018-BE0C-025FC2116643"><a name="GUID-ACCCB148-DAF9-59EC-B585-8EF632B9BF04__GUID-33AD25F2-E58E-5018-BE0C-025FC2116643"><!-- --></a>
SELECT *
FROM node AS n1 CROSS JOIN
 edge AS e CROSS JOIN
 node AS n2
WHERE n1.name = 'alice'
 AND n2.name = 'bob'
 AND e.orig = n1.id
 AND e.dest = n2.id;
</pre>
 <p>The CROSS JOIN keyword phrase is perfectly valid SQL syntax
according to the SQL standard, but it is syntax that is rarely if ever used
in real-world SQL statements. Because it is so rarely used otherwise, SQLite
has appropriated the phrase as a means to override the table reordering decisions
of the query optimizer. </p>
 <p>The CROSS JOIN connector is rarely needed
and should probably never be used prior to the final performance tuning phase
of application development. Even then, SQLite usually gets the order of tables
in a join right without any extra help. But on those rare occasions when SQLite
gets it wrong, the CROSS JOIN connector is an invaluable way of tweaking the
optimizer to do what you want. </p>
 </div>

</div>
<div>
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a href="GUID-831F9AA3-0209-53DC-96C4-04157F22870C.html" title="This topic discusses tips for SQL developers.">SQL Developer Tips</a></div>
</div>
<div class="relinfo relconcepts"><strong>Related concepts</strong><br/>
<div><a href="GUID-22844C28-AB5B-5A6F-8863-7269464684B4.html" title="This document introduces you to the Symbian platform implementation of the Structured Query Language(SQL).">SQL Overview</a></div>
<div><a href="GUID-78773BCA-ADF6-53E6-AC80-5CB2AE1F8BCC.html" title="This topic introduces you to the SQL server.">SQL Server
Guide</a></div>
<div><a href="GUID-1F12E3F5-45B2-55EC-B021-00338277C608.html" title="Used to access and query relational databases using the SQL query language.">SQL DB Overview</a></div>
<div><a href="GUID-43CA02E7-0101-5824-B91B-E15EE20C829A.html" title="This guide gives advice for avoiding the use of transient tables.">Avoid Transient
Tables</a></div>
<div><a href="GUID-49A3419F-D20A-5C5D-B2FF-51724EF37704.html">Prevent Datafile
Corruption</a></div>
<div><a href="GUID-C2FAEBB2-4A1A-5BB0-9670-4801525CBC6A.html" title="This document includes several tips for using SQL indexes.">SQL Index
Tips</a></div>
<div><a href="GUID-B994E6F7-228A-5433-B87F-91857C5D93D6.html" title="This guide provides some tips for using COMMIT statements.">SQL Insertion
Tips</a></div>
<div><a href="GUID-4FC23DB7-4758-5DA4-81FF-0DAB169E2757.html" title="This guide gives tips for using the database schema.">SQL Schema
Tips</a></div>
<div><a href="GUID-2A2920E0-5D40-5358-BC0C-8572CEFE078C.html" title="This document explains how the optimizer changes expressions.">SQL Expressions</a></div>
<div><a href="GUID-126FCCCC-0E7D-59AE-959A-2F94A7319C4B.html" title="This guide provides tips for using certain SQL statements.">SQL Statement
Tips</a></div>
<div><a href="GUID-B7E978C1-45CA-554C-8028-D901B97BA2E0.html" title="This guide gives details of how to use the ANALYZE command to help the optimizer."> ANALYZE
Command</a></div>
<div><a href="GUID-AF5A75D7-0687-546C-87B2-0B7DF7D33217.html" title="This guide provides tips for using the WHERE clause."> SQL WHERE
CLause Tips</a></div>
</div>
</div>   
<p class="copyright">Copyright &#169;2010 Nokia Corporation and/or its subsidiary(-ies).<br /> All rights
reserved. Unless otherwise stated, these materials are provided under the terms of the <a href=" http://www.eclipse.org/legal/epl-v10.html"> Eclipse Public License
v1.0</a>.</p> 
</div>
</div>
<?php include_once (CURRENT_SKIN_PATH.'/sdl_footer.html'); ?>

</body>
</html>