<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="copyright" content="(C) Copyright 2010"/>
<meta name="DC.rights.owner" content="(C) Copyright 2010"/>
<meta name="DC.Type" content="concept"/>
<meta name="DC.Title" content="Publish and Subscribe"/>
<meta name="abstract" content="Publish and Subscribe allows global variables to be set and retrieved, and allows subscribers to be notified that variables have changed."/>
<meta name="description" content="Publish and Subscribe allows global variables to be set and retrieved, and allows subscribers to be notified that variables have changed."/>
<meta name="DC.Relation" scheme="URI" content="GUID-DC8D3736-EDCF-54CB-A614-2AAC4664F1CA.html"/>
<meta name="DC.Relation" scheme="URI" content="index.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-32E29020-1956-461A-B79A-1492E06049E7.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-C14B2552-43A7-4499-ABFE-1725128DA6EF.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-F78B7BF9-5FDD-4EF8-A921-71CCBB830A99.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-DC8D3736-EDCF-54CB-A614-2AAC4664F1CA.html"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D"/>
<meta name="DC.Language" content="en"/>
<link rel="stylesheet" type="text/css" href="commonltr.css"/>
<title>Publish and Subscribe</title>

     
<link type="text/css" rel="stylesheet" href="css/common.css" media="screen"/>
<link type="text/css" rel="stylesheet" href="css/sdl.css" media="screen"/>

<!--[if IE]>
<link href="css/iefix.css" rel="stylesheet" type="text/css" media="screen" />
<![endif]-->



     <link rel="stylesheet" type="text/css" href="nokiacxxref.css"/></head>
<body id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D"><!-- --></a>


<?php include_once (CURRENT_SKIN_PATH.'/sdl_header.html'); ?>
<div id="sdl_container">
   <div id="leftMenu">  
 <div id="expandcontractdiv">
    <a id="collapseTree" href="javascript:tree.collapseAll()">Collapse all</a>
    <a id="index" href="index.html">Symbian^3 Product Developer Library</a>        
</div>
     <iframe style="border:none" height="800" width="300" src="index-toc.html"></iframe>
<div id="treeDiv1">&#160;</div>
     <script type="text/javascript">
	var currentIconMode = 0; window.name="id2563754 id2387835 id2387995 id2388473 ";
	YAHOO.util.Event.onDOMReady(buildTree, this,true);
    </script>
     
</div>

<div id="sdl_content">


<div class="breadcrumb"><a href="index.html" title="Symbian^3 Product Developer Library">Symbian^3 Product Developer Library</a> &gt; <a href="GUID-32E29020-1956-461A-B79A-1492E06049E7.html" title="The Symbian Guide describes the architecture and functionality of the platform, and provides guides on using its APIs.">Symbian Guide</a> &gt; <a href="GUID-C14B2552-43A7-4499-ABFE-1725128DA6EF.html" title="Kernel and Hardware Services performs the fundamental operating system tasks of managing access to device resources.">Kernel and Hardware Services Guide</a> &gt; <a href="GUID-F78B7BF9-5FDD-4EF8-A921-71CCBB830A99.html" title="The device driver framework and how to implement a device driver.">Device Driver Guide</a> &gt; <a href="GUID-DC8D3736-EDCF-54CB-A614-2AAC4664F1CA.html" title="This section describes how device drivers can use the services that the Kernel provides.">Kernel-Side Services</a> &gt; </div>
<h1 class="topictitle1">Publish
and Subscribe</h1>
<div><p>Publish and Subscribe allows global variables to be set and retrieved,
and allows subscribers to be notified that variables have changed. </p>

<p>The general pattern for using on the kernel side is almost the same as
for the user side. However, different classes are used on the kernel side.
It may be useful to compare kernel side usage with user side usage as described
in the <a href="GUID-A81C65CF-CF4E-571C-8080-9D387F46AAD6.html" title="This section explains the publish and subscribe concepts.">Publish and
Subscribe</a> guide for the user-side API. </p>

<ul>
<li id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-BDAE8BFE-B0F9-5A3D-9E2B-6AC6280195E5"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-BDAE8BFE-B0F9-5A3D-9E2B-6AC6280195E5"><!-- --></a><p> <a href="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D.html#GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-AD33A76A-9A27-5D66-B583-64F360EC996E">Properties</a> </p>
 </li>

<li id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-3D892E85-C506-5FF6-A8E2-3A9458800CBB"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-3D892E85-C506-5FF6-A8E2-3A9458800CBB"><!-- --></a><p> <a href="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D.html#GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-E2261227-E747-53E0-9EE3-9CEC824C1832">Creating and closing a reference to a property</a>  </p>
 </li>

<li id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-728CCCEB-8F5F-5CA1-A650-803C94E64194"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-728CCCEB-8F5F-5CA1-A650-803C94E64194"><!-- --></a><p> <a href="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D.html#GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-C41886EF-24EC-58C2-A906-C4890CED3F3A">Defining a property</a>  </p>
 </li>

<li id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-FB0EC3DC-38E1-5701-AF84-47A814238163"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-FB0EC3DC-38E1-5701-AF84-47A814238163"><!-- --></a><p> <a href="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D.html#GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-60F19D41-F9B5-5A21-9654-5D96CA6EE83E">Deleting a property</a>  </p>
 </li>

<li id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-FAE51C6E-1C39-593C-B2AD-7BEFAA257F72"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-FAE51C6E-1C39-593C-B2AD-7BEFAA257F72"><!-- --></a><p> <a href="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D.html#GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-EBAA6B5C-CC73-5AE2-85CA-68B445828608">Publishing a property value</a>  </p>
 </li>

<li id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-2F1A3E2F-44C8-5532-8FA2-F49A4FC58623"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-2F1A3E2F-44C8-5532-8FA2-F49A4FC58623"><!-- --></a><p> <a href="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D.html#GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-CA858A2A-4BF0-565D-8A6D-58AE32FEE304">Retrieving a property value</a>  </p>
 </li>

<li id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-C39FCE8D-082E-56E8-85B2-137B25B88C61"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-C39FCE8D-082E-56E8-85B2-137B25B88C61"><!-- --></a><p> <a href="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D.html#GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-984AB90D-FCCD-5383-B5D9-8D80AA83D989">Subscribing to, and unsubscribing from, a property </a>  </p>
 </li>

<li id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-E02C9293-56B4-5AC0-9DA8-F47E6796A07D"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-E02C9293-56B4-5AC0-9DA8-F47E6796A07D"><!-- --></a><p> <a href="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D.html#GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-21D8ADCA-9B39-5079-B4AD-FEBFCCB92049">Usage patterns</a>  </p>
 </li>

</ul>

<div class="section" id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-AD33A76A-9A27-5D66-B583-64F360EC996E"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-AD33A76A-9A27-5D66-B583-64F360EC996E"><!-- --></a><h2 class="sectiontitle">Properties</h2> <p>A
property has the two attributes: identity and type. </p>
 <p><strong>Identity</strong> </p>
 <p>A
property is identified by a 64-bit integer made up of two 32-bit parts: the
category and the key. </p>
 <p>A property belongs to a category, and a category
is identified by a UID. </p>
 <p>A key is a 32-bit value that identifies a
specific property within a category. The meaning applied to the key depends
on the kind of enumeration scheme set up for the category. At its simplest,
a key can be an index value. It can also be another UID, if the category is
designed to be generally extensible. </p>
 <p><strong>Type</strong> </p>
 <p>A property
can be: </p>
 <ul>
<li id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-083AF1CA-ACA1-53A3-A251-370DD1D06554"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-083AF1CA-ACA1-53A3-A251-370DD1D06554"><!-- --></a><p>a single 32-bit value </p>
 </li>

<li id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-6EA61CFF-F549-5FA2-A6AA-43683C802B8D"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-6EA61CFF-F549-5FA2-A6AA-43683C802B8D"><!-- --></a><p>a contiguous set of
bytes, referred to as a byte-array, whose length can vary from 0 to 512 bytes </p>
 </li>

</ul>
<p>Once defined, a property value can change, but the property type cannot.
Byte-array type properties can also change length provided the length does
not exceed the value <a href="GUID-C4776034-D190-3FC4-AF45-C7F195093AC3.html#GUID-C4776034-D190-3FC4-AF45-C7F195093AC3__GUID-57E64054-610A-31D1-AD7F-E2F9F9FC1DCB"><span class="apiname">RProperty::KMaxPropertySize</span></a>. The limit
on size of property ensures some limit on RAM usage. </p>
<p>The API allows
a byte-array text type property to be pre-allocated when it is defined. This
means that the time taken to set the values is bounded. However, if the length
of this property type subsequently increases, then memory allocation may take
place, and no guarantees can be made on the time taken to set them.</p>
<p>Note
that the <a href="GUID-C4776034-D190-3FC4-AF45-C7F195093AC3.html#GUID-C4776034-D190-3FC4-AF45-C7F195093AC3__GUID-F8DE443B-B208-353C-A98E-AA52C4FE6530"><span class="apiname">RProperty::ELargeByteArray</span></a> property type can never
provide a real-time guarantee. </p>
<p>For code running kernel side, properties
and their values are defined, set and retrieved using a <a href="GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2.html"><span class="apiname">RPropertyRef</span></a> object.</p>
 </div>

<div class="section" id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-E2261227-E747-53E0-9EE3-9CEC824C1832"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-E2261227-E747-53E0-9EE3-9CEC824C1832"><!-- --></a><h2 class="sectiontitle">Creating and
closing a reference to a property</h2> <p>On the kernel side, all accesses
to a property <em>must</em> be done through a property reference, an instance
of a <a href="GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2.html"><span class="apiname">RPropertyRef</span></a>. </p>
 <p>You must create a reference
to a property, before doing any operation on that property. By operation,
we mean defining a property, subscribing to a property, publishing and retrieving
a property value. The kernel will fault if you have not first created a reference. </p>
 <p>Only
one property, as uniquely identified by its category and key, can be accessed
by an instance of <a href="GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2.html"><span class="apiname">RPropertyRef</span></a>; however a property can
be referenced by more than one instance of <a href="GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2.html"><span class="apiname">RPropertyRef</span></a>. </p>
 <p>Internally,
properties are represented by <samp class="codeph">TProperty</samp> objects, and these
are reference counted. The act of creating a reference to a property results
either in the creation of a <samp class="codeph">TProperty</samp> object or an increase
in the reference count of an existing object. The property itself has no attributes
or "structure" until it is defined. </p>
 <p>Please note that the structure
and management of <samp class="codeph">TProperty</samp> objects are part of Symbian platform's
internal implementation and will not be discussed further. </p>
 <div class="fignone" id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-8A0D9C1E-00D7-5369-AD9C-28AA9151612F"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-8A0D9C1E-00D7-5369-AD9C-28AA9151612F"><!-- --></a><span class="figcap">Figure 1. Objects internal to Symbian platform</span>

<img src="GUID-31CE66F2-B36C-56ED-A399-BA9EFA179DED_d0e306443_href.png"/>
</div>
 <p>To establish a reference to a property, create an <a href="GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2.html"><span class="apiname">RPropertyRef</span></a> object,
and then use one of the following functions: </p>
 <ul>
<li id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-87D76A73-6429-5D4C-8321-A98F756C30F5"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-87D76A73-6429-5D4C-8321-A98F756C30F5"><!-- --></a><p> <a href="GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2.html#GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2__GUID-DBEDDC3A-AE6F-3CAF-B251-4AA556EAF21C"><span class="apiname">RPropertyRef::Attach()</span></a> -
tries to open the property identified by the category and key, if it exists,
but creates that property if it does not exist. Creation is simply the act
of creating the internal <samp class="codeph">TProperty</samp> object. The object has
no type or "structure" associated with it other than the use of the category
and key as identification markers. </p>
 </li>

<li id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-7D1AFF17-BB0A-57B9-9782-001E983D9EDE"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-7D1AFF17-BB0A-57B9-9782-001E983D9EDE"><!-- --></a><p> <a href="GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2.html#GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2__GUID-6F8EB0AB-C01A-3BFD-B334-D9C9FB923865"><span class="apiname">RPropertyRef::Open()</span></a> -
tries to open the property identified by the category and key, and assumes
that the property already exists; this fails if the property does not exist. </p>
 </li>

</ul>
 <p>You can call these functions from a user thread running in supervisor
mode, from a kernel thread or from a DFC. If calling from a user thread running
in supervisor mode, then your thread must be running in a critical section.
In debug mode, if a user thread is not in a critical section, then the kernel
will fault. </p>
 <p>On successful return from these functions, the <a href="GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2.html"><span class="apiname">RPropertyRef</span></a> object
owns a resource, the property, and this can then be defined and accessed through
the <a href="GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2.html"><span class="apiname">RPropertyRef</span></a> object. </p>
 <p>It is difficult to make
firm rules as to which one your code should use, but generally, you use <samp class="codeph">Open()</samp> if
you have no responsibility or interest in ensuring that the property exists.
You would use <samp class="codeph">Attach()</samp> if you were to have single or <em>joint</em> responsibility
for ensuring that the property exists. It depends on the intent of the property
and the role of your driver code in the system. </p>
 <p>Note that responsibility
for creating the property does not necessarily align with who can define,
delete, publish (write) or retrieve (read) a property value. This is governed
by the intent of the property and, for retrieving and publishing, by the security
policies in place. </p>
 <p>When the property is no longer needed, you can
release it by calling <a href="GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2.html#GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2__GUID-3465CD78-C107-3AD9-AEAF-F97A94C1C462"><span class="apiname">RPropertyRef::Close()</span></a>. Closing the
reference does not cause the property to disappear. This only happens when
the <em>final</em> reference to the property is closed. </p>
 <p>Note that it
is quite legitimate to attach to, or to open, a property that has not been
defined, and in this case no error will be returned either. This enables the
lazy definition of properties as used in some of the usage patterns. </p>
 <pre class="codeblock" id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-7F4295E4-F822-5128-B4EC-3AD3E71BD444"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-7F4295E4-F822-5128-B4EC-3AD3E71BD444"><!-- --></a>const TUid KMyPropertyCat={0x10012345};
enum TMyPropertyKeys={EMyPropertyCounter,EMyPropertyName};

. . .

// Attach to the ‘counter’ property. This creates the property
// if it does not already exist.
RPropertyRef counter;
TInt r;
r=counter.Attach(KMyPropertyCat,EMyPropertyCounter);

// r should be KErrNone if sucessful or KErrNoMemory if there
// is an out of memory failure.
if (r != KErrNone)
    {
    // Handle the bad return value
    }

// use the counter object...

// when finished, release the property
counter.Close();
    </pre>
 </div>

<div class="section" id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-C41886EF-24EC-58C2-A906-C4890CED3F3A"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-C41886EF-24EC-58C2-A906-C4890CED3F3A"><!-- --></a><h2 class="sectiontitle">Defining a
property </h2> <p>Defining a property gives it "structure" i.e. attributes
such as the property type, and the security policies that define the capabilities
that a process must have to publish and retrieve the property value. </p>
 <p>A
property is defined using the <a href="GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2.html#GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2__GUID-47F367CB-E663-3F97-AC0C-31A9DD6BD5E5"><span class="apiname">RPropertyRef::Define()</span></a> function.
You can call this function from a user thread running in supervisor mode,
from a kernel thread or from a DFC. If calling from a user thread running
in supervisor mode, then your thread must be running in a critical section.
In debug mode, if a user thread is not in a critical section, then the kernel
will fault. </p>
 <p>You can call this function from a user thread running
in supervisor mode, from a kernel thread or from a DFC. If calling from a
user thread running in supervisor mode, then your thread must be running in
a critical section. In debug mode, if a user thread is not in a critical section,
then the kernel will fault. </p>
 <p>The information needed to define the property
is passed to <samp class="codeph">Define()</samp>. Note that a reference to the property
must already have been established using <a href="GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2.html#GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2__GUID-DBEDDC3A-AE6F-3CAF-B251-4AA556EAF21C"><span class="apiname">RPropertyRef::Attach()</span></a> or <a href="GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2.html#GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2__GUID-6F8EB0AB-C01A-3BFD-B334-D9C9FB923865"><span class="apiname">RPropertyRef::Open()</span></a>. </p>
 <p>A
property does not need to be defined before it can be accessed. This supports
programming patterns where both publishers and subscribers may define the
property. </p>
 <p>Once defined, a property persists until the system reboots,
or the property is explicitly deleted. Its lifetime is not tied to that of
the thread or process that originally defined it. This means that, when defining
a property, it is important to check the return code from the call to <a href="GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2.html#GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2__GUID-47F367CB-E663-3F97-AC0C-31A9DD6BD5E5"><span class="apiname">RPropertyRef::Define()</span></a> to
deal with the possibility that the property has previously been defined. </p>
 <p>The
following code shows the definition of two properties, which we call: 'name'
and 'counter': </p>
 <pre class="codeblock" id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-318DC2A6-FFE4-5781-9F78-5D5B4392585F"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-318DC2A6-FFE4-5781-9F78-5D5B4392585F"><!-- --></a>const TUid KMyPropertyCat={0x10012345};
enum TMyPropertyKeys={EMyPropertyCounter,EMyPropertyName};

static _LIT_SECURITY_POLICY_PASS(KAllowAllPolicy);
static _LIT_SECURITY_POLICY_C1(KPowerMgmtPolicy,ECapabilityPowerMgmt);

TInt r;

// Attaches to the ‘counter’ property. 
// If the property already exists, a new reference to it is created.
// If the property does not exist, it is created.
RPropertyRef counter;
r=counter.Attach(KMyPropertyCat,EMyPropertyCounter);
if (r != KErrNone)
    {
    // Handle the bad return value
    }

// Attaches to the ‘name’ property. 
// If the property already exists, a new reference to it is created.
// If the property does not exist, it is created.
RPropertyRef name;
r=name.Attach(KMyPropertyCat,EMyPropertyName);
if (r != KErrNone)
    {
    // Handle the bad return value
    }

// Now define the 'counter' property:
// 1. Integer type
// 2. Pre-allocated size has no meaning, and must be zero.
// 3. Allow all processes to retrieve (read) the property.
// 4. Only processes with power managament capability can write.
// 5. Capability checks to be done against client thread's process.

r=counter.Define(RProperty::EInt,KAllowAllPolicy,KPowerMgmtPolicy,0,iClientProcess);

// You will probably need to check the return value.
// It may legitimately by non-KErrNone.

...

// Now define the 'name' property:
// 1. Byte array
// 2. Pre-allocate 100 bytes.
// 3. Allow all processes to retrieve (read) the property.
// 4. Only processes with power managament capability can write.
// 5. Capability checks to be done against client thread's process.

r=name.Define(RProperty::EByteArray,KAllowAllPolicy,KPowerMgmtPolicy,100,iClientProcess);

// You will probably need to check the return value.
// It may legitimately be non-KErrNone.
...</pre>
 <p>Once defined, a property value can change, but the property
type cannot. Byte-array type properties can also change length provided the
length does not exceed the 512 bytes, for <a href="GUID-C4776034-D190-3FC4-AF45-C7F195093AC3.html#GUID-C4776034-D190-3FC4-AF45-C7F195093AC3__GUID-19066DA4-B407-3C31-8472-371CA341BDC7"><span class="apiname">RProperty::EByteArray</span></a> types
or 65535 bytes or <a href="GUID-C4776034-D190-3FC4-AF45-C7F195093AC3.html#GUID-C4776034-D190-3FC4-AF45-C7F195093AC3__GUID-F8DE443B-B208-353C-A98E-AA52C4FE6530"><span class="apiname">RProperty::ELargeByteArray</span></a> types. </p>
 <p>The
API allows byte-array type properties to be pre-allocated when they are defined.
This means that the time taken to set the values is bounded. However, if the
length of these property types subsequently increases, then memory allocation
may take place, and no guarantees can then be made on the time taken to set
them. </p>
 <p> <strong>Security notes:</strong>  </p>
 <ul>
<li id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-E46B65DD-5D93-5796-8762-D8637947350D"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-E46B65DD-5D93-5796-8762-D8637947350D"><!-- --></a><p>Symbian platform defines
a property category known as the system category that is reserved for system
services, and is identified by the <a href="GUID-A85740BD-BC85-345E-B24A-92F68EA56270.html"><span class="apiname">KUidSystemCategoryValue</span></a> UID.
To define a property within this category, then the process on whose behalf
your code is doing the define operation must have the <em>writeDeviceData</em> capability, <a href="GUID-C607209F-6FC5-31DE-8034-E5B799B857A8.html"><span class="apiname">ECapabilityWriteDeviceData</span></a>. </p>
 <p>To
ensure that this security check is made, you must pass a pointer to the appropriate <samp class="codeph">DProcess</samp> object
as the second parameter to <samp class="codeph">Define()</samp>. If you omit this parameter,
a null pointer is assumed by default, and <em>the security check is bypassed</em>.
This may be legitimate if you are doing this on behalf of the kernel or on
behalf of the driver itself. </p>
 </li>

<li id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-18AA5E54-23AE-564F-BCB0-0F9FF70DEFD5"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-18AA5E54-23AE-564F-BCB0-0F9FF70DEFD5"><!-- --></a><p>Whether you pass a <samp class="codeph">DProcess</samp> pointer
or not, the owner of the property is deemed to be the process that is <em>current</em> when
the code runs. It is this, the current process, that you will need to pass
to <a href="GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2.html#GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2__GUID-73FB49F1-E9EF-3CE3-A317-8888BAE49403"><span class="apiname">RPropertyRef::Delete()</span></a> at a later time. </p>
 </li>

<li id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-A941BD4F-E288-5A71-9F78-08351665AE73"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-A941BD4F-E288-5A71-9F78-08351665AE73"><!-- --></a><p>You also need to define
two security policies: one to define the capabilities that will be required
to publish (write to) the property, and the other to define the capabilities
that will be required to retrieve (read) the property. Security policies are <a href="GUID-81A285F6-3F87-3E77-9426-61BB16BC7109.html"><span class="apiname">TSecurityPolicy</span></a> objects
or their static equivalents. </p>
 <p>In the above code fragment, we specify
that all processes in the system will be able to read the defined property
but only those with power management capability will be able to write to the
property - this is an arbitrary choice and is for illustration only. </p>
 </li>

</ul>
 <p>In the above code fragments, <samp class="codeph">iClientProcess</samp> is a
pointer to the client thread's owning process object, and assumes that the
driver code is making the request on behalf of a client, although this may
not necessarily be so. Typically, if you need to keep this information, you
could set this up in the logical channel constructor using the following code: </p>
 <pre class="codeblock" id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-33D0D5EA-8BB2-57DB-A327-D17A6A5C2D8E"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-33D0D5EA-8BB2-57DB-A327-D17A6A5C2D8E"><!-- --></a>iClientProcess=&amp;Kern::CurrentProcess();</pre>
 <p>The
constructor code runs in the context of the client user thread. Note that <samp class="codeph">DProcess</samp> is
internal to Symbian. </p>
 </div>

<div class="section" id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-60F19D41-F9B5-5A21-9654-5D96CA6EE83E"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-60F19D41-F9B5-5A21-9654-5D96CA6EE83E"><!-- --></a><h2 class="sectiontitle">Deleting a
property </h2> <p>Deleting a property is the opposite of defining it. It
removes type and security information. It does <em>not</em> remove a reference
to the property. </p>
 <p>A property is deleted using the <a href="GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2.html#GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2__GUID-73FB49F1-E9EF-3CE3-A317-8888BAE49403"><span class="apiname">RPropertyRef::Delete()</span></a> function.
You can call this function from a user thread running in supervisor mode,
from a kernel thread or from a DFC. If calling from a user thread running
in supervisor mode, then your thread must be running in a critical section.
In debug mode, if a user thread is not in a critical section, then the kernel
will fault. </p>
 <p>Any outstanding subscriptions for this property complete
with <a href="GUID-5E653C17-372C-32E1-A1B2-9E69A9991C40.html"><span class="apiname">KErrNotFound</span></a>. </p>
 <p> <strong>Security notes:</strong>  </p>
 <ul>
<li id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-1B901363-70E9-560B-9C56-C63BB6D180C0"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-1B901363-70E9-560B-9C56-C63BB6D180C0"><!-- --></a><p>Only the owning process
is allowed to delete the property. This is deemed to be the process that was
current when the property was defined. However, to enforce this, you <em>must</em> pass
into <a href="GUID-331FCC3D-B326-37A1-8AF5-381320224BBE.html#GUID-331FCC3D-B326-37A1-8AF5-381320224BBE__GUID-2838E746-C917-3FB0-B2BA-464C38B5944B"><span class="apiname">RPropertyref::Delete()</span></a> a pointer to the <samp class="codeph">DProcess</samp> object
that represents the owning process. If you omit to pass this parameter to <samp class="codeph">Delete()</samp>,
a null pointer is assumed by default, and <em>the security check is bypassed.</em>.
This may be legitimate if you are doing this on behalf of the kernel or on
behalf of the driver itself. </p>
 </li>

</ul>
 <p>For example, extending the code fragment introduced in defining a
property above: </p>
 <pre class="codeblock" id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-25FBD12A-4461-5A92-9961-960DB26FE3F8"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-25FBD12A-4461-5A92-9961-960DB26FE3F8"><!-- --></a>const TUid KMyPropertyCat={0x10012345};
enum TMyPropertyKeys={EMyPropertyCounter,EMyPropertyName};

static _LIT_SECURITY_POLICY_PASS(KAllowAllPolicy);
static _LIT_SECURITY_POLICY_C1(KPowerMgmtPolicy,ECapabilityPowerMgmt);

TInt r;

// Attaches to the ‘counter’ property. 
// If the property already exists, a new reference to it is created.
// If the property does not exist, it is created.
RPropertyRef counter;
r=counter.Attach(KMyPropertyCat,EMyPropertyCounter);
if (r != KErrNone)
    {
    // Handle the bad return value
    }

// Attaches to the ‘name’ property. 
// If the property already exists, a new reference to it is created.
// If the property does not exist, it is created.
RPropertyRef name;
r=name.Attach(KMyPropertyCat,EMyPropertyName);
if (r != KErrNone)
    {
    // Handle the bad return value
    }

// Now define the 'counter' property:
// 1. Integer type
// 2. Pre-allocated size has no meaning, and must be zero.
// 3. Allow all processes to retrieve (read) the property.
// 4. Only processes with power managament capability can write.
// 5. Capability checks to be done against client thread's process.

r=counter.Define(RProperty::EInt,KAllowAllPolicy,KPowerMgmtPolicy,0,iClientProcess);

// You will probably need to check the return value.
// It may legitimately by non-KErrNone.

...

// Now define the 'name' property:
// 1. Byte array
// 2. Pre-allocate 100 bytes.
// 3. Allow all processes to retrieve (read) the property.
// 4. Only processes with power managament capability can write.
// 5. Capability checks to be done against client thread's process.

r=name.Define(RProperty::EByteArray,KAllowAllPolicy,KPowerMgmtPolicy,100,iClientProcess);

// You will probably need to check the return value.
// It may legitimately by non-KErrNone.

...

// Delete the ‘name’ property.
// Assumes that the owning process is iClientProcess. This will be checked
// as being the valid owner of the property.
r=name.Delete(iClientProcess);
if (r != KErrNone)
    {
    // deal with a non-KErrNone return value.
    }

// Delete the ‘counter’ property.
// Assumes that the owning process is iClientProcess. This will be checked
// as being the valid owner of the property.
r=name.Delete(iClientProcess);
if (r != KErrNone)
    {
    // deal with a non-KErrNone return value.
    }</pre>
 </div>

<div class="section" id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-EBAA6B5C-CC73-5AE2-85CA-68B445828608"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-EBAA6B5C-CC73-5AE2-85CA-68B445828608"><!-- --></a><h2 class="sectiontitle">Publishing
a property value </h2> <p>A property is published (written), using the <a href="GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2.html#GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2__GUID-D4B0220A-EB30-327C-B878-FBC5294A08F6"><span class="apiname">RPropertyRef::Set()</span></a> family
of functions. </p>
 <p>This is guaranteed to have bounded execution time, suitable
for high-priority, real-time tasks, except when publishing a byte-array property
that requires the allocation of a larger space for the new value, or when
publishing a large byte-array property type, as identified by <a href="GUID-0B4D1D87-8C1B-3AEF-9C3D-3091FBDF3A6B.html"><span class="apiname">ELargeByteArray</span></a>. </p>
 <p>Property
values are written atomically. This means that it is not possible for threads
reading a property to get a garbled value. </p>
 <p>All outstanding subscriptions
for a property are completed when the value is published, even if it is exactly
the same as the existing value. This means that a property can be used as
a simple broadcast notification service. </p>
 <p>Publishing a property that
is not defined is not necessarily a programming error. The <samp class="codeph">Set()</samp> functions
just return an error. If this is not expected for any particular usage, then
the error must be checked and processed by the caller. </p>
 <p> <strong>Security
notes:</strong>  </p>
 <ul>
<li id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-DA84723A-B9F7-525C-908A-BC51AA8B0366"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-DA84723A-B9F7-525C-908A-BC51AA8B0366"><!-- --></a><p>If you pass a pointer
to a <samp class="codeph">DProcess</samp> object, then the capabilities of that process
will be checked against those contained in the write security policy that
was created and passed to <a href="GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2.html#GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2__GUID-47F367CB-E663-3F97-AC0C-31A9DD6BD5E5"><span class="apiname">RPropertyRef::Define()</span></a>. If you
omit this <samp class="codeph">DProcess</samp> parameter, a null pointer is assumed by
default, and <em>the security check is bypassed</em>. This may be legitimate
if you are doing this on behalf of the kernel or on behalf of the driver itself. </p>
 </li>

</ul>
 <p>See the code fragment in the section <a href="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D.html#GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-CA858A2A-4BF0-565D-8A6D-58AE32FEE304">Retrieving
a property value</a>  </p>
 </div>

<div class="section" id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-CA858A2A-4BF0-565D-8A6D-58AE32FEE304"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-CA858A2A-4BF0-565D-8A6D-58AE32FEE304"><!-- --></a><h2 class="sectiontitle">Retrieving
a property value </h2> <p>The current value of a property is retrieved
(read) using the <a href="GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2.html#GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2__GUID-745E29E7-A26B-3207-ACA3-F8CC41FC7081"><span class="apiname">RPropertyRef::Get()</span></a> family of functions. </p>
 <p>This
is guaranteed to have bounded execution time, suitable for high-priority,
real-time tasks, except when retrieving a large byte-array property type,
as identified by <a href="GUID-0B4D1D87-8C1B-3AEF-9C3D-3091FBDF3A6B.html"><span class="apiname">ELargeByteArray</span></a>. </p>
 <p>Property values
are read atomically. This means that it is not possible for threads reading
a property to get a garbled value. </p>
 <p>Retrieving a property that is not
defined is not necessarily a programming error. The <samp class="codeph">Get()</samp> functions
just return an error. If this is not expected for any particular usage, then
the error must be checked and processed by the caller. </p>
 <p>Integer properties
must be accessed using the overload that takes an integer reference, whereas
a byte-array property is accessed using the overload that takes a descriptor
reference. </p>
 <p>The following code fragment shows publication and retrieval
of a property. Note that it contains a race condition, especially if another
thread is executing the same sequence to increment the ‘counter’ value. </p>
 <p> <strong>Security
notes:</strong>  </p>
 <ul>
<li id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-B117308F-416E-5BAE-880C-A162869799AD"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-B117308F-416E-5BAE-880C-A162869799AD"><!-- --></a><p>If you pass a pointer
to a <samp class="codeph">DProcess</samp> object, then the capabilities of that process
will be checked against those contained in the read security policy that was
created and passed to <a href="GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2.html#GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2__GUID-47F367CB-E663-3F97-AC0C-31A9DD6BD5E5"><span class="apiname">RPropertyRef::Define()</span></a>. If you omit
this <samp class="codeph">DProcess</samp> parameter, a null pointer is assumed by default,
and <em>the security check is bypassed</em>. This may be legitimate if you are
doing this on behalf of the kernel or on behalf of the driver itself. </p>
 </li>

</ul>
 <pre class="codeblock" id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-75549D12-A2CA-5039-BB91-2ABF19058DE5"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-75549D12-A2CA-5039-BB91-2ABF19058DE5"><!-- --></a>const TUid KMyPropertyCat={0x10012345};
enum TMyPropertyKeys={EMyPropertyCounter,EMyPropertyName};

TInt r;

RPropertyRef counter;
RPropertyRef name;


// Assume that the 'name' and 'counter' property references have
// already been created. They may have been defined.
//
// Assume that the process to be used for security checking is iClientProcess.

...

// publish a new name value. 
_LIT8(KSomeExampleName,"My example name");
r=name.Set(KSomeExampleName, iClientProcess);
if (r != KErrNone)
    {
    // Check the return value. KErrNotFound means that the property has not yet been    
    // defined which may be legitimate.
    // KErrArgument is a serious problem at this stage.
    // KErrPermissionDenied is a security violation; the process iClientProcess has 
    // insufficient capability to do this operation. 
    }


// Retrieve the first 10 characters of the name value.
// We are not doing any security checking for this operation, so no DProcess pointer 
// is passed to Get(). 
TBuf&lt;10&gt; n;
r=name.Get(n);

if ((r!= KErrNone) &amp;&amp; (r != KErrOverflow))
    {
    // Handle error value.
    }

// retrieve and publish a new value using the attached ‘counter’ property
TInt count;
r=counter.Get(count);
if (r==KErrNone)
    {
    r=counter.Set(++count);
    }
else
    {
    // Handle bad return value
    }
...

// When finised, release the property references.
counter.Close();
name.Close();</pre>
 </div>

<div class="section" id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-984AB90D-FCCD-5383-B5D9-8D80AA83D989"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-984AB90D-FCCD-5383-B5D9-8D80AA83D989"><!-- --></a><h2 class="sectiontitle">Subscribing
to, and unsubscribing from, a property </h2> <p>Subscribing to a property
is the act of making an asynchronous request to be notified of a change to
that property. </p>
 <p>You make a request for notification of a change to
a property by calling the <a href="GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2.html#GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2__GUID-6DC06192-78AF-3B3D-8077-8479789AF006"><span class="apiname">RPropertyRef::Subscribe()</span></a> member
function on a property reference object. Only one subscription request can
be outstanding at any time for a given <a href="GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2.html"><span class="apiname">RPropertyRef</span></a> instance. </p>
 <p>You
can cancel an outstanding subscription request by calling <a href="GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2.html#GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2__GUID-4AFB3074-E523-3404-8F0D-39995C35E045"><span class="apiname">RPropertyRef::Cancel()</span></a>.
This is unsubscribing from the property. </p>
 <p>Subscribing to a property
is a single request to be notified when the property is next updated, it does
not generate an ongoing sequence of notifications for every change to that
property's value. Neither does it provide the caller with the new value. In
essence, the act of notification should be interpreted as “Property X has
changed” rather than “Property X has changed to Y”. This means that the new
value must be explicitly retrieved, if required. As a result, multiple updates
may be collapsed into one notification, and subscribers may not have visibility
of all intermediate values. </p>
 <p>This might appear to introduce a window
of opportunity for a subscriber to be out of synchronisation with the property
value – in particular, if the property is updated again before the subscriber
thread has had the chance to process the original notification. However, a
simple programming pattern, outlined in the second example below ensures this
does not happen. The principle is that, before dealing with a subscription
completion event, you should re-issue the subscription request. </p>
 <p>Note
that if the property has not been defined, then a subscription request does
not complete until the property is subsequently defined and published. Note
that the request will complete with <a href="GUID-213DE05E-24F7-3E94-9B35-F4A72B3EBFD8.html"><span class="apiname">KErrPermissionDenied</span></a> if
the subscribing process does not have sufficient capability as defined by
the <a href="GUID-81A285F6-3F87-3E77-9426-61BB16BC7109.html"><span class="apiname">TSecurityPolicy</span></a> object supplied by the process defining
the property. </p>
 <p>If the property is already defined, then the request
completes immediately with <a href="GUID-213DE05E-24F7-3E94-9B35-F4A72B3EBFD8.html"><span class="apiname">KErrPermissionDenied</span></a> if the
subscribing process does not have sufficient capability. </p>
 <p>The essence
of subscribing to a property is that you pass a function into <a href="GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2.html#GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2__GUID-6DC06192-78AF-3B3D-8077-8479789AF006"><span class="apiname">RPropertyRef::Subscribe()</span></a> and
that this function is called when the property value is published. You pass
the function by wrapping it in <a href="GUID-8A0F75CD-DC61-37EA-A23A-3A82080F0751.html"><span class="apiname">TPropertySubsRequest</span></a> object
and then pass this into <samp class="codeph">Subscribe()</samp>. What the function does
depends on the implementation, but you may want to re-subscribe to the property
and then retrieve the property value, or you may want to set some flag. It
all depends on the intent of the property and the driver code. </p>
 <p>The
following code fragments show the general idea. </p>
 <pre class="codeblock" id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-DF8201DF-7812-5B39-8B0F-3CB664BA00FA"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-DF8201DF-7812-5B39-8B0F-3CB664BA00FA"><!-- --></a>const TUid KMyPropertyCat={0x10012345};
enum TMyPropertyKeys={EMyPropertyCounter,EMyPropertyName};</pre>
 <pre class="codeblock" id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-2162EE7C-B834-50ED-9C84-3CE004C0B7D6"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-2162EE7C-B834-50ED-9C84-3CE004C0B7D6"><!-- --></a>class DMyLogicalChannel : public DLogicalChannel
    {
    public :
        DMyLogicalChannel();
        void OpenReference();
        void SetUpSubscription();
        ...
    private :
        static void HandleSubsComplete(TAny* aPtr, TInt aReason);
        ...
    private:
        RCounterRef iName;
        TBuf&lt;10&gt;    iNameValue;
        DProcess    iClientProcess;
        TPropertySubsRequest iSubsRequest;
        TInt iReason;
    }</pre>
 <pre class="codeblock" id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-4A655D83-07CD-5998-A540-16D4A5EABFC5"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-4A655D83-07CD-5998-A540-16D4A5EABFC5"><!-- --></a>DMyLogicalChannel::DMyLogicalChannel() : iSubsRequest(&amp;HandleSubsComplete, this)
    {
    iClientProcess = &amp;Kern::CurrentProcess();
    // Other code omitted 
    }</pre>
 <pre class="codeblock" id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-DB6F4AF7-8866-50C5-95FD-5BCA1F2B55CE"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-DB6F4AF7-8866-50C5-95FD-5BCA1F2B55CE"><!-- --></a>void DMyLogicalChannel::OpenReference()
    {
    // Open a reference to the ‘name’ property, and assume that
    // the property has already been created and defined.
  
    TInt r
    ...
    r=iName.Open(KMyPropertyCat,EMyPropertyName);
    if (r != KErrNone)
        {
        // Handle bad return value.
        }
    ...
    }</pre>
 <pre class="codeblock" id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-217CFAF4-2CA6-588B-B3A2-667EB9A04FCA"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-217CFAF4-2CA6-588B-B3A2-667EB9A04FCA"><!-- --></a>void DMyLogicalChannel::SetUpSubscription()
    {
    // Now ask to be notified when the 'name' property is updated.
    // This will eventually result in a call to the function HandleSubsComplete()
    // at some later time (asynchronously).
    // When eventually called, the pointer to this DMyLogicalChannel object will
    // be passed to HandleSubsComplete().
    //
    ...
    iReason = KRequestPending;
    TInt r = iName.Subscribe(iSubsRequest); // ignoring security issues here.
    if (r != KErrNone)
        {
        // handle bad return code.
        }
    return;
    }</pre>
 <pre class="codeblock" id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-C2CD229F-F6CE-5EE3-9EBA-A69CED50FA07"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-C2CD229F-F6CE-5EE3-9EBA-A69CED50FA07"><!-- --></a>void DMyLogicalChannel::CancelSubscription()
    {
    if (iReason == KRequestPending)
        {
        iName.Cancel(iSubsRequest);
        }
    }</pre>
 <pre class="codeblock" id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-D5E046B5-4D56-5B82-B4B8-D943DC601338"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-D5E046B5-4D56-5B82-B4B8-D943DC601338"><!-- --></a>void DMyLogicaChannel::SubsCompleteFn(TAny* aPtr, TInt aReason)
    {
    // A static function called when a change to the property occurs.
    // aPtr will point to the DMyLogicalChannel object 
    // (see the DMyLogicalChannel constructor)
    // aReason is the reason for the subscription completing. This may be:
    //     KErrNone - for a normal completion.
    //     KErrPermissionDenied - if the security check has failed.
    //     KErrCancel - if the request was cancelled.
    // For a normal completion, setup another notification request before
    // getting the current value of the property.
    //
    DMyLogicaChannel* self = (DMyLogicaChannel*) aPtr;
       self-&gt;iReason = aReason;
    if (iReason == KErrNone)
        {
        self-&gt;SetUpSubscription();
        self-&gt;Get(iNameValue,iClientProcess);
        return;
        }
    // Investigate the non-zero reason code.
    }</pre>
 </div>

<div class="section" id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-21D8ADCA-9B39-5079-B4AD-FEBFCCB92049"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-21D8ADCA-9B39-5079-B4AD-FEBFCCB92049"><!-- --></a><h2 class="sectiontitle">Usage patterns</h2> <p>There
are three usage patterns that can easily be identified, labelled as: standard
state, pure event distribution, and speculative publishing. </p>
 <p id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-98103A8A-10E1-58FE-9613-A616E142AA2A"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-98103A8A-10E1-58FE-9613-A616E142AA2A"><!-- --></a><strong>Standard state</strong> </p>
 <p>This
pattern is used for events and state that are known to be used widely in the
system. Examples of this might be battery level and signal strength, which
are important in every phone. </p>
 <p>The publisher calls <a href="GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2.html#GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2__GUID-47F367CB-E663-3F97-AC0C-31A9DD6BD5E5"><span class="apiname">RPropertyRef::Define()</span></a> to
create the appropriate property. For byte array or text properties, a size
sufficient for all possible values should be reserved. An error of <a href="GUID-D1D25122-F2B8-3C78-8599-84905BFD47B8.html"><span class="apiname">KErrAlreadyExists</span></a> should
be ignored. The publisher then publishes the property values as, and when,
appropriate. If the <samp class="codeph">RPropertyRef::Set()</samp> call fails, this
should be treated as a serious error, since it indicates that important system
state is not getting through. Appropriate action might include panicking or
rebooting the system. Subscribers will use <a href="GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2.html#GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2__GUID-6DC06192-78AF-3B3D-8077-8479789AF006"><span class="apiname">RPropertyRef::Subscribe()</span></a> to
request notification, and <samp class="codeph">RPropertyRef::Get()</samp> to retrieve
the property value on notification. </p>
 <p>The memory to store the property
value will be permanently allocated, even if it turns out that no-one in the
system needs that value. This does ensure that the value can always be published,
even if the system is in an out of memory situation. For this reason, this
approach should be limited to widely used and important state. The <a href="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D.html#GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-8D9E6222-DDBA-55CA-A96F-1DCBD99E3FD3">Speculative publishing</a> pattern offers an approach for dealing with
less important state. </p>
 <p id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-5C82A92C-168D-5CD2-BE43-EE79AB500B14"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-5C82A92C-168D-5CD2-BE43-EE79AB500B14"><!-- --></a><strong>Pure event distribution</strong> </p>
 <p>This
pattern is used when events need to be distributed, not values. </p>
 <p>The
publisher of the event simply uses an integer property, and calls <samp class="codeph">RPropertyRef::Set()</samp> with
any value. Even if the value of the property is not changed by this operation,
all subscribers will be notified that a <samp class="codeph">Set()</samp> has occurred,
and by implication that the related event has occurred. </p>
 <p>Subscribers
will be able to detect that an event has occurred, but will get no other information.
The minimum possible memory is wasted on storage for the dummy value. </p>
 <p id="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-8D9E6222-DDBA-55CA-A96F-1DCBD99E3FD3"><a name="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-8D9E6222-DDBA-55CA-A96F-1DCBD99E3FD3"><!-- --></a><strong>Speculative publishing</strong> </p>
 <p>This
pattern is used when it is not known whether a value will be of interest to
others or not. Unlike the <a href="GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D.html#GUID-EBFD653D-6E6A-5F6F-88D7-8CCE07B4002D__GUID-98103A8A-10E1-58FE-9613-A616E142AA2A">standard
state</a> pattern, the publisher of the event does not call <a href="GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2.html#GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2__GUID-47F367CB-E663-3F97-AC0C-31A9DD6BD5E5"><span class="apiname">RPropertyRef::Define()</span></a> to
create the property. Instead, it simply calls <samp class="codeph">RPropertyRef::Set()</samp> as
appropriate, and ignores any <a href="GUID-5E653C17-372C-32E1-A1B2-9E69A9991C40.html"><span class="apiname">KErrNotFound</span></a> error. </p>
 <p>When
other code in the system, i.e. a potential subscriber, is interested in the
state, it calls <a href="GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2.html#GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2__GUID-47F367CB-E663-3F97-AC0C-31A9DD6BD5E5"><span class="apiname">RPropertyRef::Define()</span></a> to create the property
and allocate the memory for the value. An error of <a href="GUID-D1D25122-F2B8-3C78-8599-84905BFD47B8.html"><span class="apiname">KErrAlreadyExists</span></a> should
be ignored, as this only indicates that some other code in the system is also
interested in the value and has already created the property. </p>
 <p>The
subscriber then calls <a href="GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2.html#GUID-39D6B924-3FA3-39E6-A6EA-88E2D1927AC2__GUID-6DC06192-78AF-3B3D-8077-8479789AF006"><span class="apiname">RPropertyRef::Subscribe()</span></a> and <samp class="codeph">RPropertyRef::Get()</samp> as
usual to interact with the property. On the first <samp class="codeph">Get()</samp>,
the subscriber may retrieve the property default value (zero, or a zero length
descriptor). This must be substituted with a sensible default value for the
property in question. </p>
 <p>Using this pattern, no memory is wasted on properties
that have no subscribers, while the publisher code is simpler as there is
no need for configuration as to which properties to publish. </p>
 <p>The publisher,
however, wastes some time attempting to publish unneeded values, but this
should not be an issue unless the value is very frequently updated. </p>
 <p>Where
events are published very infrequently, the subscriber could have a dummy
value for a long time, until the next publish event updates the value. Often
this is not a problem as a default value can be substituted. For example a
full/empty indicator for a battery level, none for signal strength etc. This
pattern is unlikely to be useful if there is no suitable default value. </p>
 </div>

</div>
<div>
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a href="GUID-DC8D3736-EDCF-54CB-A614-2AAC4664F1CA.html" title="This section describes how device drivers can use the services that the Kernel provides.">Kernel-Side Services</a></div>
</div>
</div>
   
<p class="copyright">Copyright &#169;2010 Nokia Corporation and/or its subsidiary(-ies).<br /> All rights
reserved. Unless otherwise stated, these materials are provided under the terms of the <a href=" http://www.eclipse.org/legal/epl-v10.html"> Eclipse Public License
v1.0</a>.</p> 
</div>
</div>
<?php include_once (CURRENT_SKIN_PATH.'/sdl_footer.html'); ?>

</body>
</html>