<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="copyright" content="(C) Copyright 2010"/>
<meta name="DC.rights.owner" content="(C) Copyright 2010"/>
<meta name="DC.Type" content="concept"/>
<meta name="DC.Title" content="How to use the resizable buffer descriptor - RBuf"/>
<meta name="abstract" content="Use this descriptor to hold a string or binary data."/>
<meta name="description" content="Use this descriptor to hold a string or binary data."/>
<meta name="DC.Relation" scheme="URI" content="GUID-E8BEE049-6814-543B-8A88-889E434A5D92.html"/>
<meta name="DC.Relation" scheme="URI" content="index.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-32E29020-1956-461A-B79A-1492E06049E7.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-C14B2552-43A7-4499-ABFE-1725128DA6EF.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-0DF9E318-BE97-531E-AB39-A7B5E8787C87.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-A63025D1-7FD4-5120-8A1F-537D6B70103D.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-DBF88873-21B1-5493-8EBF-C9071D314A09.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-11EEFB3D-0414-5BEB-9D78-56A4B9154008.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-E8BEE049-6814-543B-8A88-889E434A5D92.html"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A"/>
<meta name="DC.Language" content="en"/>
<link rel="stylesheet" type="text/css" href="commonltr.css"/>
<title>How to use the resizable buffer descriptor - RBuf</title>

     
<link type="text/css" rel="stylesheet" href="css/common.css" media="screen"/>
<link type="text/css" rel="stylesheet" href="css/sdl.css" media="screen"/>

<!--[if IE]>
<link href="css/iefix.css" rel="stylesheet" type="text/css" media="screen" />
<![endif]-->



     <link rel="stylesheet" type="text/css" href="nokiacxxref.css"/></head>
<body id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A"><!-- --></a>


<?php include_once (CURRENT_SKIN_PATH.'/sdl_header.html'); ?>
<div id="sdl_container">
   <div id="leftMenu">  
 <div id="expandcontractdiv">
    <a id="collapseTree" href="javascript:tree.collapseAll()">Collapse all</a>
    <a id="index" href="index.html">Symbian^3 Product Developer Library</a>        
</div>
     <iframe style="border:none" height="800" width="300" src="index-toc.html"></iframe>
<div id="treeDiv1">&#160;</div>
     <script type="text/javascript">
	var currentIconMode = 0; window.name="id2563754 id2387835 id2392072 id2392081 id2392600 id2392686 id2392788 ";
	YAHOO.util.Event.onDOMReady(buildTree, this,true);
    </script>
     
</div>

<div id="sdl_content">


<div class="breadcrumb"><a href="index.html" title="Symbian^3 Product Developer Library">Symbian^3 Product Developer Library</a> &gt; <a href="GUID-32E29020-1956-461A-B79A-1492E06049E7.html" title="The Symbian Guide describes the architecture and functionality of the platform, and provides guides on using its APIs.">Symbian Guide</a> &gt; <a href="GUID-C14B2552-43A7-4499-ABFE-1725128DA6EF.html" title="Kernel and Hardware Services performs the fundamental operating system tasks of managing access to device resources.">Kernel and Hardware Services Guide</a> &gt; <a href="GUID-0DF9E318-BE97-531E-AB39-A7B5E8787C87.html" title="Provides a framework for accessing file systems.">User Library and File Server</a> &gt; <a href="GUID-A63025D1-7FD4-5120-8A1F-537D6B70103D.html" title="The User Library allows the applications and services that run on a phone to access the functionality provided by the Symbian platform Kernel.">User Library</a> &gt; <a href="GUID-DBF88873-21B1-5493-8EBF-C9071D314A09.html" title="Links to documents that describe buffers and strings.">Buffers And Strings</a> &gt; <a href="GUID-11EEFB3D-0414-5BEB-9D78-56A4B9154008.html" title="This is a list of documents that describe how to use descriptors.">Using Descriptors</a> &gt; <a href="GUID-E8BEE049-6814-543B-8A88-889E434A5D92.html" title="Explains how to use descriptors for various use cases.">How to Use Descriptors</a> &gt; </div>
<h1 class="topictitle1">How to
use the resizable buffer descriptor - RBuf</h1>
<div><p>Use this descriptor to hold a string or binary data.</p>

<p>A resizable buffer descriptor is an <a href="GUID-BFBC574B-EFF6-37A4-9189-B71DA1505BC8.html"><span class="apiname">RBuf</span></a> type. Use the
member functions of the base classes: <a href="GUID-49D4E917-57EA-39AE-8941-144AA8AC2584.html"><span class="apiname">TDes</span></a> and <a href="GUID-52D07F46-2162-380C-A775-C3BB335C42F5.html"><span class="apiname">TDesC</span></a> to
change the data in the descriptor. See <a href="GUID-C85B4EA2-0184-52AF-B097-152E4A023CEF.html" title="Describes the modifiable descriptor class and the non-modifiable descriptor class.">Abstract
base descriptor classes</a>. </p>

<p>This buffer of the descriptor is put on the heap. The buffer is the place
where the data is put. This is useful if you do not know the maximum size
of the data until run time. </p>

<p>The resizable buffer descriptors are similar to what are called <a href="GUID-2762FDF6-F76D-5268-AE2D-4ABA807CFFEE.html" title="Describes heap descriptors.">Heap
descriptors</a>, or <a href="GUID-A103FB19-60B3-3E45-97A5-1F295934ACA1.html"><span class="apiname">HBufC</span></a> types, but the API provided
by <samp class="codeph">RBuf</samp> is easier to use. The <samp class="codeph">RBuf</samp> API also
makes it easier to change the maximum size of the buffer containing the data,
a task often referred to as reallocating the buffer. </p>

<p>The general guidelines are: use <a href="GUID-A103FB19-60B3-3E45-97A5-1F295934ACA1.html"><span class="apiname">HBufC</span></a> descriptors to
contain data that rarely changes; use <a href="GUID-BFBC574B-EFF6-37A4-9189-B71DA1505BC8.html"><span class="apiname">RBuf</span></a> descriptors
to contain data that changes frequently. However, in practice, <samp class="codeph">RBuf</samp> types
are equally suitable for both cases, and you should <em>always consider</em> using
an <samp class="codeph">RBuf</samp> in preference to an <samp class="codeph">HBufC</samp>. </p>

<p>For cases where your code uses APIs that return an <samp class="codeph">HBufC</samp> type,
you can convert this to an <samp class="codeph">RBuf</samp>. In effect, <samp class="codeph">RBuf</samp> can
act as a wrapper around the <samp class="codeph">HBufC</samp>; access and manipulation
of the data is then done through the member functions of <a href="GUID-BFBC574B-EFF6-37A4-9189-B71DA1505BC8.html"><span class="apiname">RBuf</span></a> and
its base classes <a href="GUID-49D4E917-57EA-39AE-8941-144AA8AC2584.html"><span class="apiname">TDes</span></a> and <a href="GUID-52D07F46-2162-380C-A775-C3BB335C42F5.html"><span class="apiname">TDesC</span></a>  </p>

<p>Some key points about resizable buffer descriptors: </p>

<ul>
<li id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-C9051973-DFA3-57E6-8AD2-E6E1B49B0A74"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-C9051973-DFA3-57E6-8AD2-E6E1B49B0A74"><!-- --></a><p>For text data, it is
usual to construct an <samp class="codeph">RBuf</samp> type and allow the appropriate
variant, either a <a href="GUID-955061A8-A83E-39E5-8745-8FAC7DEA7BCC.html"><span class="apiname">RBuf8</span></a> or a <a href="GUID-BEFF9C91-DA64-3032-96E8-F5054405DC74.html"><span class="apiname">RBuf16</span></a> to
be selected at build time. </p>
 </li>

<li id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-93CD2C60-ABB6-5063-8CCA-B63B09139A3F"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-93CD2C60-ABB6-5063-8CCA-B63B09139A3F"><!-- --></a><p>For binary data, an
explicit <a href="GUID-955061A8-A83E-39E5-8745-8FAC7DEA7BCC.html"><span class="apiname">RBuf8</span></a> is used. </p>
 </li>

<li id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-82B1C228-51A3-5FED-9797-206805BD3DA5"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-82B1C228-51A3-5FED-9797-206805BD3DA5"><!-- --></a><p>It is rare to use an
explicit <a href="GUID-BEFF9C91-DA64-3032-96E8-F5054405DC74.html"><span class="apiname">RBuf16</span></a>. </p>
 </li>

<li id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-2F339945-4741-59A1-AEAA-B405379E25DB"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-2F339945-4741-59A1-AEAA-B405379E25DB"><!-- --></a><p>Data can be changed
through <samp class="codeph">RBuf</samp> as well as replaced using its assignment operators.
Like all descriptors, <samp class="codeph">RBuf</samp> is derived from: </p>
 <ul>
<li id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-7145D7BB-ABCC-5BF8-B367-6D8F9C308AF9"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-7145D7BB-ABCC-5BF8-B367-6D8F9C308AF9"><!-- --></a><p>the <a href="GUID-49D4E917-57EA-39AE-8941-144AA8AC2584.html"><span class="apiname">TDes</span></a> class,
through which the data can be manipulated </p>
 </li>

<li id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-18DF3A17-15E7-54C7-8E3D-1A968AD46D14"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-18DF3A17-15E7-54C7-8E3D-1A968AD46D14"><!-- --></a><p>the <a href="GUID-52D07F46-2162-380C-A775-C3BB335C42F5.html"><span class="apiname">TDesC</span></a> class,
through which information about the data (such as its length) can be retrieved. </p>
 </li>

</ul>
 </li>

<li id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-F2EE3065-3D20-5D2B-9887-2C2181FB0195"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-F2EE3065-3D20-5D2B-9887-2C2181FB0195"><!-- --></a><p>You can pass an <samp class="codeph">RBuf</samp> to
a function that takes a <samp class="codeph">TDesC&amp;</samp> parameter, and a <samp class="codeph">TDes&amp;</samp> parameter. </p>
 </li>

<li id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-83C851DA-BC8C-543D-9987-656FA19832C2"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-83C851DA-BC8C-543D-9987-656FA19832C2"><!-- --></a><p>Memory that has already
been allocated by your code can be transferred to an <samp class="codeph">RBuf</samp>.
This allows any data that may be in that location to be managed through the
descriptor. </p>
 </li>

<li id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-6C6B51EE-486C-5ED1-A343-F6777DB5D130"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-6C6B51EE-486C-5ED1-A343-F6777DB5D130"><!-- --></a><p>Ownership of an existing <samp class="codeph">HBufC</samp> can
be transferred to an <samp class="codeph">RBuf</samp>. This allows the data contained
within the <samp class="codeph">HBufC</samp> to be managed through the <samp class="codeph">RBuf</samp> API. </p>
 </li>

</ul>

<p>Although the following notes refer to the build independent types, they
are equally valid for the explicit 8-bit and 16-bit types. </p>

<ul>
<li id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-9506E27E-3079-52A9-A993-4DD1DE1BB50B"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-9506E27E-3079-52A9-A993-4DD1DE1BB50B"><!-- --></a><p> <a href="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A.html#GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-A72C3172-7185-5D87-B4CB-6266AC6146A3">Creating an RBuf</a>  </p>
 </li>

<li id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-C7A121AA-401B-5524-A171-E84352170D71"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-C7A121AA-401B-5524-A171-E84352170D71"><!-- --></a><p> <a href="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A.html#GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-2B23F296-D414-5ABD-82CA-DDCEE2F48459">Re-allocating the memory buffer</a>  </p>
 </li>

<li id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-AC98AE5C-AF3F-5105-BDFF-958D080C92E1"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-AC98AE5C-AF3F-5105-BDFF-958D080C92E1"><!-- --></a><p> <a href="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A.html#GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-A6368F43-9A67-5583-B279-FE68B8CADEC4">Freeing the memory buffer</a>  </p>
 </li>

<li id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-883D98FB-E588-5BCB-A0C0-A64465BFDDA7"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-883D98FB-E588-5BCB-A0C0-A64465BFDDA7"><!-- --></a><p> <a href="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A.html#GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-7ECF515D-D538-5F6C-B2A0-88C1B4E3505C">Cleanup rules</a>  </p>
 </li>

<li id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-94E02925-DDB7-5C8E-9B5B-E98DA78D65D4"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-94E02925-DDB7-5C8E-9B5B-E98DA78D65D4"><!-- --></a><p> <a href="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A.html#GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-6732B0A9-4E6E-50A8-9C4F-ADB2BB8FBAEF">Replacing and modifying data</a>  </p>
 </li>

</ul>

<div class="section" id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-A72C3172-7185-5D87-B4CB-6266AC6146A3"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-A72C3172-7185-5D87-B4CB-6266AC6146A3"><!-- --></a><h2 class="sectiontitle">Creating an
RBuf</h2> <p>An <a href="GUID-BFBC574B-EFF6-37A4-9189-B71DA1505BC8.html"><span class="apiname">RBuf</span></a> object behaves like a handle to
a resource. In this case, the resource is the buffer that contains the data.
While this might seem to be an implementation issue, you need to understand
that much of the interface provided by the <samp class="codeph">RBuf</samp> class itself
is involved in allocating, freeing and resizing this buffer. </p>
 <p>An <samp class="codeph">RBuf</samp> object
can: </p>
 <ul>
<li id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-38116609-9E75-57B4-9F34-FEC8AD3AA285"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-38116609-9E75-57B4-9F34-FEC8AD3AA285"><!-- --></a><p>be placed on the program
stack. </p>
 </li>

<li id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-FD4007BC-6EA8-5DC0-B61E-59B2BA17B5C2"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-FD4007BC-6EA8-5DC0-B61E-59B2BA17B5C2"><!-- --></a><p>be a member of another
'C' type class. </p>
 </li>

</ul>
 <p>An <samp class="codeph">RBuf</samp> object cannot be a member of a 'T' type
class. </p>
 <p>See also <a href="GUID-2458916B-55B2-5E08-A825-4EBDB3503E67.html">Class
types</a>. </p>
 <p>The default constructor does not allocate a buffer,
and means that, by default, the object represents no data. In descriptor terminology,
its length is zero and its maximum length is zero. </p>
 <p>Before an <samp class="codeph">RBuf</samp> can
hold any data, you need to create the buffer. </p>
 <ul>
<li id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-8BD20341-B902-5BD2-B121-3596432F4CC9"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-8BD20341-B902-5BD2-B121-3596432F4CC9"><!-- --></a><p> <a href="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A.html#GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-A15FC714-C2D3-51F9-A336-4043F9F6DA1C">Simple construction</a>  </p>
 </li>

<li id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-7EFD2DA7-C50D-54E8-9343-FC26F07387CD"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-7EFD2DA7-C50D-54E8-9343-FC26F07387CD"><!-- --></a><p> <a href="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A.html#GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-82460E76-D738-51BD-AC7F-29C2CA54C597">More advanced construction</a>  </p>
 </li>

<li id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-3A9847B8-8741-5543-B5B2-D7FEB1EB3C4A"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-3A9847B8-8741-5543-B5B2-D7FEB1EB3C4A"><!-- --></a><p> <a href="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A.html#GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-19A5BFF9-0B7E-54C1-BC27-2F69B65FAC47">Creating an RBuf from an existing descriptor</a>  </p>
 </li>

<li id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-BDE8E0A0-0FF6-5BF2-B276-9B9750DDA383"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-BDE8E0A0-0FF6-5BF2-B276-9B9750DDA383"><!-- --></a><p> <a href="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A.html#GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-2C934B0F-97D7-5118-A6C4-7CE375F6E0F7">Creating an RBuf by transferring ownership of a pre-existing buffer</a>  </p>
 </li>

</ul>
 <p id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-A15FC714-C2D3-51F9-A336-4043F9F6DA1C"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-A15FC714-C2D3-51F9-A336-4043F9F6DA1C"><!-- --></a><strong>Simple construction</strong> </p>
 <p>The
simplest way to create the buffer is to use the <samp class="codeph">Create()</samp> or
the <samp class="codeph">CreateL()</samp> member functions of <a href="GUID-BFBC574B-EFF6-37A4-9189-B71DA1505BC8.html"><span class="apiname">RBuf</span></a> [See <a href="GUID-BEFF9C91-DA64-3032-96E8-F5054405DC74.html#GUID-BEFF9C91-DA64-3032-96E8-F5054405DC74__GUID-E5E4895B-4BA2-3EB1-AB7E-D676374F12E2"><span class="apiname">RBuf16::Create()</span></a> and <a href="GUID-BEFF9C91-DA64-3032-96E8-F5054405DC74.html#GUID-BEFF9C91-DA64-3032-96E8-F5054405DC74__GUID-AE30A4E2-0F85-32F3-A4A7-3A8FF8A5B856"><span class="apiname">RBuf16::CreateL()</span></a>]. </p>
 <p>For example, the following code fragment constructs a resizable
buffer descriptor that can hold up to 15 data items. In descriptor terminology,
this means that the maximum length is set to 15. The current length of the
descriptor is set to zero, i.e. it contains no data. </p>
 <pre class="codeblock" id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-CA817431-E554-5BBA-994F-BDE6FD30B802"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-CA817431-E554-5BBA-994F-BDE6FD30B802"><!-- --></a>RBuf buf;
...
buf.CreateL(15);
...</pre>
 <p>Note that <samp class="codeph">CreateL()</samp> is similar to <samp class="codeph">Create()</samp>,
but leaves if memory cannot be allocated. </p>
 <p id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-82460E76-D738-51BD-AC7F-29C2CA54C597"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-82460E76-D738-51BD-AC7F-29C2CA54C597"><!-- --></a><strong>More advanced construction</strong> </p>
 <p>A
variation on the simple creation technique is to use the <samp class="codeph">CreateMax()</samp> or
the <samp class="codeph">CreateMaxL()</samp> member functions of <a href="GUID-BFBC574B-EFF6-37A4-9189-B71DA1505BC8.html"><span class="apiname">RBuf</span></a> [See <a href="GUID-BEFF9C91-DA64-3032-96E8-F5054405DC74.html#GUID-BEFF9C91-DA64-3032-96E8-F5054405DC74__GUID-E5E4895B-4BA2-3EB1-AB7E-D676374F12E2"><span class="apiname">RBuf16::Create()</span></a> and <a href="GUID-BEFF9C91-DA64-3032-96E8-F5054405DC74.html#GUID-BEFF9C91-DA64-3032-96E8-F5054405DC74__GUID-AE30A4E2-0F85-32F3-A4A7-3A8FF8A5B856"><span class="apiname">RBuf16::CreateL()</span></a>]. </p>
 <p>These functions not only allocate the buffer, but set the current
length of the data to be the same as the maximum length. For example: </p>
 <pre class="codeblock" id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-C2FA200E-5D22-5A6D-B192-04B83509D9ED"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-C2FA200E-5D22-5A6D-B192-04B83509D9ED"><!-- --></a>RBuf buf;
...
buf.CreateMaxL(15);
...</pre>
 <p>No data has been assigned to the descriptor, and in effect
it contains "arbitrary" data. However, this can be useful in cases where the
descriptor needs to have a current length before calling another function.
For example, you might want a buffer of 16 bytes initialised to binary zeroes: </p>
 <pre class="codeblock" id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-C0B7F0CA-A5D9-5E9E-8DEE-C8BB983B5D4F"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-C0B7F0CA-A5D9-5E9E-8DEE-C8BB983B5D4F"><!-- --></a>RBuf8 buf;
...
buf.CreateMaxL(15);
buf.Fillz();
...</pre>
 <p> <samp class="codeph">FillZ()</samp> provided by the <a href="GUID-445B19E5-E2EE-32E2-8D6C-C7D6A9B3C507.html"><span class="apiname">TDes8</span></a> base
class, sets the data to binary zeroes for the length of the descriptor, 15
bytes in this example. Note that we have explicitly used the 8-bit variant
here. </p>
 <p>There are other ways of achieving this, but this is an economical
technique. </p>
 <p id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-19A5BFF9-0B7E-54C1-BC27-2F69B65FAC47"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-19A5BFF9-0B7E-54C1-BC27-2F69B65FAC47"><!-- --></a><strong>Creating an RBuf from an
existing descriptor</strong> </p>
 <p>A common requirement is to create an <a href="GUID-BFBC574B-EFF6-37A4-9189-B71DA1505BC8.html"><span class="apiname">RBuf</span></a> and
to copy the data from an existing descriptor of any type. <samp class="codeph">RBuf</samp> provides
variants of <samp class="codeph">Create()</samp> and <samp class="codeph">CreateL()</samp> to do
this. </p>
 <p>In the following code fragment, a <a href="GUID-0B9C8884-6BFF-35E2-AA6F-E4057B85AFCF.html"><span class="apiname">TBuf</span></a> descriptor
is passed to a function, which then passes it to this <samp class="codeph">CreateL()</samp> variant.
The source descriptor has a maximum length of 15, which means that the <samp class="codeph">RBuf</samp> buffer
is allocated so that the <samp class="codeph">RBuf</samp> maximum length is also 15. </p>
 <p>The
content of the source descriptor is copied into the <samp class="codeph">RBuf</samp>,
and the length of the <samp class="codeph">RBuf</samp> (i.e. the length of data that
the descriptor represents) is set to be the same as that of the source descriptor
- in this case 11. </p>
 <pre class="codeblock" id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-4961B664-D22A-5086-97B4-C52E8EB96101"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-4961B664-D22A-5086-97B4-C52E8EB96101"><!-- --></a>_LIT(KSampleText,"Hello World");
...
TBuf&lt;15&gt; sampletext(KSampleText);
FuncL(sampletext);
...
void FuncL(TDesC&amp; aSource)
    {
    RBuf buf;

    buf.CreateL(aSource);
    ...
    }
</pre>
 <p>The following code fragment constructs a resizable buffer
descriptor and copies data from a source descriptor. The length of data copied
is limited by the value of the second parameter. If this is less than the
length of the source descriptor, then only this length of data is copied.
The buffer allocated is large enough to contain data of length specified by
this second parameter. </p>
 <p>This is often used in cases where the length
of the source data is not easily predictable, and it is important to limit
the size of the <samp class="codeph">RBuf</samp> buffer created. </p>
 <p>There are two
possibilities in this code fragment : </p>
 <ul>
<li id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-90C4F9FE-BE4B-52B1-96F6-89803743D065"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-90C4F9FE-BE4B-52B1-96F6-89803743D065"><!-- --></a><p>if the length of <samp class="codeph">aSource</samp> is
20, then the maximum length of <samp class="codeph">buf</samp> is limited to 10, only
half the data in <samp class="codeph">aSource</samp> is copied, and the length of <samp class="codeph">buf</samp> is
set to 10. </p>
 </li>

<li id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-1FF37B48-27C9-5B60-8443-46633F609548"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-1FF37B48-27C9-5B60-8443-46633F609548"><!-- --></a><p>if the length of <samp class="codeph">aSource</samp> is
8, then the maximum length of <samp class="codeph">buf</samp> is still set to 10; all
8 items are copied, and the length of <samp class="codeph">buf</samp> is set to 8. </p>
 </li>

</ul>
 <pre class="codeblock" id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-A7309735-947B-57AF-9EA3-F2721EBFDDBD"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-A7309735-947B-57AF-9EA3-F2721EBFDDBD"><!-- --></a>void FuncL(TDesC&amp; aSource)
    {
    RBuf buf;
    ...
    buf.CreateL(aSource,10);
    ...
    }
</pre>
 <p id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-2C934B0F-97D7-5118-A6C4-7CE375F6E0F7"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-2C934B0F-97D7-5118-A6C4-7CE375F6E0F7"><!-- --></a><strong>Creating an RBuf by transferring
ownership of a pre-existing buffer</strong> </p>
 <p>An important technique is to
create an <a href="GUID-BFBC574B-EFF6-37A4-9189-B71DA1505BC8.html"><span class="apiname">RBuf</span></a> and transfer ownership of existing allocated
memory to it. This allows any data in that block of memory to be managed through
the <samp class="codeph">RBuf</samp>. </p>
 <p>There are three main cases to consider: </p>
 <ul>
<li id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-E5C30864-1E72-54EC-B321-3A5F27D5A590"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-E5C30864-1E72-54EC-B321-3A5F27D5A590"><!-- --></a><p>transferring ownership
of a preexisting heap descriptor, an <a href="GUID-A103FB19-60B3-3E45-97A5-1F295934ACA1.html"><span class="apiname">HBufC</span></a> type. </p>
 </li>

<li id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-9E7CC922-7B86-5044-A5D7-CFCB76617312"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-9E7CC922-7B86-5044-A5D7-CFCB76617312"><!-- --></a><p>transferring ownership
of allocated memory </p>
 </li>

<li id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-45EDF081-0E89-50EE-96D7-4E2FF28993B3"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-45EDF081-0E89-50EE-96D7-4E2FF28993B3"><!-- --></a><p>transferring ownership
of the buffer owned by a different <samp class="codeph">RBuf</samp>. </p>
 </li>

</ul>
 <p id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-11BEB9E8-CE72-5DF8-869E-2C2FF9E43A35"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-11BEB9E8-CE72-5DF8-869E-2C2FF9E43A35"><!-- --></a><strong> Transferring ownership
of an HBufC</strong> </p>
 <p>This is a mechanism you would use if an existing API
returned an <a href="GUID-A103FB19-60B3-3E45-97A5-1F295934ACA1.html"><span class="apiname">HBufC</span></a>, and you wanted to deal with its data
through an <a href="GUID-BFBC574B-EFF6-37A4-9189-B71DA1505BC8.html"><span class="apiname">RBuf</span></a> instead. </p>
 <p>The following code fragment
shows how this could be done. Note that the <samp class="codeph">HBufC</samp> pointer
is passed to the <samp class="codeph">RBuf</samp> constructor. </p>
 <p>Following construction,
ownership of the heap descriptor has been passed to the <samp class="codeph">RBuf</samp> object.
In descriptor terminology, the maximum length of the <samp class="codeph">RBuf</samp> is
15, and its length is 11, reflecting the state of the original <samp class="codeph">HBufC</samp> object. </p>
 <p>You
can now manipulate any data that may have been assigned to the original <samp class="codeph">HBufC</samp>,
through the functions in the <samp class="codeph">RBuf</samp> base classes. </p>
 <pre class="codeblock" id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-C5351B54-85D9-5E98-A781-F9B00A06A87D"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-C5351B54-85D9-5E98-A781-F9B00A06A87D"><!-- --></a>HBufC* hptr;
_LIT(KSampleText,"Hello World");
...
hptr = HBufC::NewL(15);    // Creates a heap descriptor which can hold up
...                        // to 15 data items. The current length is zero.
*hptr = KSampleText;     // Assigns some data to the heap descriptor.
...                        // The current length of the heap descriptor is now 11.
RBuf buf(hptr);            // Ownership of the heap descriptor is passed
...                        // to the RBuf during construction of the RBuf.
</pre>
 <p>There is an alternative technique that allows you to assign
ownership of the <samp class="codeph">HBufC</samp>  <em>after</em> construction of the <samp class="codeph">RBuf</samp> using
the <samp class="codeph">Assign()</samp> function. This allows you to reuse the same <samp class="codeph">RBuf</samp> object.
For example: </p>
 <pre class="codeblock" id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-DE70696E-3E46-5377-8A10-6141BF58DB1B"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-DE70696E-3E46-5377-8A10-6141BF58DB1B"><!-- --></a>HBufC* hptr;
_LIT(KSampleText,"Hello World");
...
hptr = HBufC::NewL(15);    // Creates a heap descriptor which can hold up
...                        // to 15 data items. The current length is zero.
*hptr = KSampleText;     // Assigns some data to the heap descriptor.
...                        // The current length of the heap descriptor is now 11.
RBuf buf;
...
buf.Assign(hptr);        // Ownership of the heap descriptor is passed
...                        // to the RBuf after construction of the RBuf.
</pre>
 <p>Once ownership has been transferred, you must not access the
data through the original <samp class="codeph">HBufC</samp> pointer. </p>
 <p>There is
no mechanism for reversing the transfer of ownership. The freeing of the buffer
can only be done through the <samp class="codeph">RBuf</samp>. See <a href="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A.html#GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-A6368F43-9A67-5583-B279-FE68B8CADEC4">Freeing the buffer</a>. </p>
 <p><strong>Transferring
ownership of allocated memory</strong> </p>
 <p>In the following code fragment, <samp class="codeph">ptr</samp> is
assumed to contain the address of memory previously allocated. The code fragment
shows how ownership of this memory can be transferred to the <samp class="codeph">RBuf</samp>. </p>
 <pre class="codeblock" id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-B9FCCFE5-A448-598A-A1F2-DAEB1563274D"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-B9FCCFE5-A448-598A-A1F2-DAEB1563274D"><!-- --></a>TUint16* ptr;
TInt length(32);
...                // Assume memory of length 32 has been allocated
                // and its address stored in ptr.

RBuf buf;
...
buf.Assign(ptr,length);
...                // The memory passed to the descriptor becomes the
                // descriptor's buffer. In descriptor terminology,
                // the maximum length of the RBuf is 32; its length
                // is zero, meaning that the descriptor represents
                // no data.
</pre>
 <p><strong> Transferring
ownership of the buffer owned by a different RBuf</strong> </p>
 <p>In the following
code fragment, an <samp class="codeph">RBuf</samp> is created, a buffer created for it,
and then ownership is transferred to another <samp class="codeph">RBuf</samp>. </p>
 <pre class="codeblock" id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-4A96EC93-A868-5463-8FED-E849BF0B7A00"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-4A96EC93-A868-5463-8FED-E849BF0B7A00"><!-- --></a>RBuf bufSource;
RBuf bufTarget;
...
bufSource.CreateL(15);    // Creates memory buffer for the descriptor
                        // that can hold up to 15 data items. In descriptor
                        // terminology, the maximum length is set to 15 and
                        // the current length is set to 0.

bufTarget.Assign(bufSource); // Transfers ownership of the memory buffer
                             // to the bufTarget descriptor.
...</pre>
 </div>

<div class="section" id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-2B23F296-D414-5ABD-82CA-DDCEE2F48459"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-2B23F296-D414-5ABD-82CA-DDCEE2F48459"><!-- --></a><h2 class="sectiontitle">Re-allocating
the memory buffer</h2> <p>You can change the size of the memory buffer,
by using the <samp class="codeph">ReAlloc()</samp> or <samp class="codeph">ReAllocL()</samp> member
functions of <samp class="codeph">RBuf</samp>. </p>
 <p>It does not matter how the original
buffer was allocated, whether directly via <samp class="codeph">Create()</samp>, <samp class="codeph">CreateL()</samp>, <samp class="codeph">CreateMax()</samp> or <samp class="codeph">CReateMaxL()</samp>, or by transfer of ownership of an existing buffer (and this includes transfer
from an <samp class="codeph">HBufC</samp>). You do this if you intend to increase (or
significantly decrease) the amount of data that the descriptor is to represent.
Remember that the amount of memory allocated to the buffer is not automatically
changed in response to changes in the amount of data. </p>
 <p>In the following
code fragment, an <samp class="codeph">RBuf</samp> is created by copying from an existing
descriptor. It is then reallocated so that its maximum length is doubled.
Error conditions, such as out-of-memory conditions are ignored. </p>
 <pre class="codeblock" id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-198E0563-2A7E-52B1-A46E-8A1AD5263234"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-198E0563-2A7E-52B1-A46E-8A1AD5263234"><!-- --></a>_LIT(KSampleText,"Hello World");
...
TBuf&lt;15&gt; sampletext(KSampleText);
FuncL(sampletext);
...
void FuncL(TDesC&amp; aSource)
    {
    RBuf buf;
    Tint max;

    buf.CreateL(aSource);    // max size is 15, length is 11.
    max = buf.MaxLength() * 2;    
    buf.ReallocL(max);        // max size is now 30, but length is still 11.
    ...
    }
</pre>
 </div>

<div class="section" id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-A6368F43-9A67-5583-B279-FE68B8CADEC4"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-A6368F43-9A67-5583-B279-FE68B8CADEC4"><!-- --></a><h2 class="sectiontitle">Freeing the
buffer</h2> <p>You can free the memory buffer by calling <samp class="codeph">ReAlloc()</samp> or <samp class="codeph">ReAllocL()</samp> and
passing a zero value. </p>
 <pre class="codeblock" id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-DCC63874-8DAF-530A-9BA4-F7559E773BEC"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-DCC63874-8DAF-530A-9BA4-F7559E773BEC"><!-- --></a>_LIT(KSampleText,"Hello World");
...
TBuf&lt;15&gt; sampletext(KSampleText);
FuncL(sampletext);
...
void FuncL(TDesC&amp; aSource)
    {
    RBuf buf;

    buf.CreateL(aSource);    // max size is 15, length is 11.
    buf.ReallocL(0);        // max size is now 0, length is 0, the memory
                            // buffer has been freed, and data
                            // has been thrown away.
    ...
    }
</pre>
 <p>You can also use the <samp class="codeph">Close()</samp> member function
of <samp class="codeph">RBuf</samp>. For example: </p>
 <pre class="codeblock" id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-2D298A5F-FFB4-584C-9D9C-58A95A88E078"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-2D298A5F-FFB4-584C-9D9C-58A95A88E078"><!-- --></a>_LIT(KSampleText,"Hello World");
...
TBuf&lt;15&gt; sampletext(KSampleText);
FuncL(sampletext);
...
void FuncL(TDesC&amp; aSource)
    {
    RBuf buf;

    buf.CreateL(aSource);    // max size is 15, length is 11.
    buf.Close();            // max size is now 0, length is 0, the memory
                            // buffer has been freed, and data
                            // has been thrown away.
    ...
    }
</pre>
 </div>

<div class="section" id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-7ECF515D-D538-5F6C-B2A0-88C1B4E3505C"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-7ECF515D-D538-5F6C-B2A0-88C1B4E3505C"><!-- --></a><h2 class="sectiontitle">Cleanup rules</h2> <ul>
<li id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-38476044-1EB5-5488-93A0-CB2C7D2D38B4"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-38476044-1EB5-5488-93A0-CB2C7D2D38B4"><!-- --></a><p>To avoid memory leaks
when the <samp class="codeph">RBuf</samp> object is placed on the stack, you should use
the following programming pattern: </p>
 <pre class="codeblock" id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-1B602EF6-BAAC-5F4F-AFF2-B8C2102687D5"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-1B602EF6-BAAC-5F4F-AFF2-B8C2102687D5"><!-- --></a>{
RBuf buf;
buf.CleanupClosePushL();
...                                 // Use the RBuf
CleanupStack::PopAndDestroy()    //remove from cleanup stack
                                // and free the buffer to avoid memory 
}</pre>
 <p>The <samp class="codeph">CleanupClosePushL()</samp> function puts a
cleanup item onto the cleanup stack. The effect of this is to cause the class's <a href="GUID-01D2AF56-21E1-3FF3-BF86-0C356A1658EF.html"><span class="apiname">Close()</span></a> function
to be called in the event of a leave occurring. In its turn, <samp class="codeph">Close()</samp> simply
frees off the buffer. </p>
 </li>

<li id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-E285FB76-1079-5F34-8CC5-CE1A5AC39E70"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-E285FB76-1079-5F34-8CC5-CE1A5AC39E70"><!-- --></a><p>If an <samp class="codeph">RBuf</samp> is
a member of a class, then that class's destructor must remember to call either
: <samp class="codeph">ReAllocL(0)</samp> or <samp class="codeph">Close()</samp>. </p>
 </li>

<li id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-4B09CAD1-6E16-5FB6-9574-277CE75A48C7"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-4B09CAD1-6E16-5FB6-9574-277CE75A48C7"><!-- --></a><p>An <samp class="codeph">RBuf</samp> can
be reused, but you must remember to call either : <samp class="codeph">ReAllocL(0)</samp> or <samp class="codeph">Close()</samp> before
you assign other memory or another <samp class="codeph">HBufC</samp>. Failure to do this
will result in a memory leak. </p>
 </li>

<li id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-433E518F-A96F-5EB8-A2BF-DC4D213A2CF0"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-433E518F-A96F-5EB8-A2BF-DC4D213A2CF0"><!-- --></a><p>You should not use an <samp class="codeph">RBuf</samp> as
a member of a 'T' type class. See <a href="GUID-2458916B-55B2-5E08-A825-4EBDB3503E67.html">Class
types</a>. </p>
 </li>

</ul>
 </div>

<div class="section" id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-6732B0A9-4E6E-50A8-9C4F-ADB2BB8FBAEF"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-6732B0A9-4E6E-50A8-9C4F-ADB2BB8FBAEF"><!-- --></a><h2 class="sectiontitle">Replacing and
modifying data</h2> <p>Data in an <samp class="codeph">RBuf</samp> descriptor can
be replaced. It can also be modified using the standard functionality provided
by the <a href="GUID-49D4E917-57EA-39AE-8941-144AA8AC2584.html"><span class="apiname">TDes</span></a> base class. </p>
 <pre class="codeblock" id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-A507DCDF-F440-51B0-B6CE-86993FE5D7AB"><a name="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A__GUID-A507DCDF-F440-51B0-B6CE-86993FE5D7AB"><!-- --></a>_LIT(KSampleText,"Hello World");
...
TBuf&lt;15&gt; sampletext(KSampleText);
FuncL(sampletext);
...
void FuncL(TDesC&amp; aSource)
    {
    RBuf buf;

    buf.CreateL(aSource.MaxLength());    // Create the RBuf.
    buf = aSource;                        // Copy "Hello World" using the assignment
                                        // operator.

    buf.Delete(1,1);                    // Delete the 1st character.
    ...
    buf.Close();
    }
</pre>
 </div>

</div>
<div>
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a href="GUID-E8BEE049-6814-543B-8A88-889E434A5D92.html" title="Explains how to use descriptors for various use cases.">How to Use Descriptors</a></div>
</div>
</div>
   
<p class="copyright">Copyright &#169;2010 Nokia Corporation and/or its subsidiary(-ies).<br /> All rights
reserved. Unless otherwise stated, these materials are provided under the terms of the <a href=" http://www.eclipse.org/legal/epl-v10.html"> Eclipse Public License
v1.0</a>.</p> 
</div>
</div>
<?php include_once (CURRENT_SKIN_PATH.'/sdl_footer.html'); ?>

</body>
</html>