<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="copyright" content="(C) Copyright 2010"/>
<meta name="DC.rights.owner" content="(C) Copyright 2010"/>
<meta name="DC.Type" content="concept"/>
<meta name="DC.Title" content="File Server Extensions Tutorial"/>
<meta name="DC.Relation" scheme="URI" content="GUID-F3BD37EC-0CCB-5859-908F-215E22C9FC20.html"/>
<meta name="DC.Relation" scheme="URI" content="index.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-32E29020-1956-461A-B79A-1492E06049E7.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-C14B2552-43A7-4499-ABFE-1725128DA6EF.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-0DF9E318-BE97-531E-AB39-A7B5E8787C87.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-F3BD37EC-0CCB-5859-908F-215E22C9FC20.html"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81"/>
<meta name="DC.Language" content="en"/>
<link rel="stylesheet" type="text/css" href="commonltr.css"/>
<title>File Server Extensions Tutorial</title>

     
<link type="text/css" rel="stylesheet" href="css/common.css" media="screen"/>
<link type="text/css" rel="stylesheet" href="css/sdl.css" media="screen"/>

<!--[if IE]>
<link href="css/iefix.css" rel="stylesheet" type="text/css" media="screen" />
<![endif]-->



     <link rel="stylesheet" type="text/css" href="nokiacxxref.css"/></head>
<body id="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81"><a name="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81"><!-- --></a>


<?php include_once (CURRENT_SKIN_PATH.'/sdl_header.html'); ?>
<div id="sdl_container">
   <div id="leftMenu">  
 <div id="expandcontractdiv">
    <a id="collapseTree" href="javascript:tree.collapseAll()">Collapse all</a>
    <a id="index" href="index.html">Symbian^3 Product Developer Library</a>        
</div>
     <iframe style="border:none" height="800" width="300" src="index-toc.html"></iframe>
<div id="treeDiv1">&#160;</div>
     <script type="text/javascript">
	var currentIconMode = 0; window.name="id2563754 id2387835 id2392072 id2399453 ";
	YAHOO.util.Event.onDOMReady(buildTree, this,true);
    </script>
     
</div>

<div id="sdl_content">


<div class="breadcrumb"><a href="index.html" title="Symbian^3 Product Developer Library">Symbian^3 Product Developer Library</a> &gt; <a href="GUID-32E29020-1956-461A-B79A-1492E06049E7.html" title="The Symbian Guide describes the architecture and functionality of the platform, and provides guides on using its APIs.">Symbian Guide</a> &gt; <a href="GUID-C14B2552-43A7-4499-ABFE-1725128DA6EF.html" title="Kernel and Hardware Services performs the fundamental operating system tasks of managing access to device resources.">Kernel and Hardware Services Guide</a> &gt; <a href="GUID-0DF9E318-BE97-531E-AB39-A7B5E8787C87.html" title="Provides a framework for accessing file systems.">User Library and File Server</a> &gt; <a href="GUID-F3BD37EC-0CCB-5859-908F-215E22C9FC20.html" title="The File Server component manages all files on a Symbian platform phone. This section describes how to extend the File Server for your phone hardware.">File Server Extensions</a> &gt; </div>
<h1 class="topictitle1">File
Server Extensions Tutorial</h1>
<div>
<p>Describes how to develop and use a file server extension. </p>

<p>See <a href="GUID-983F0ABD-470C-51C3-B6AE-1B1AA55AB4A2.html" title="This document provides an overview of the file server extension architecture, and of the APIs that allows file server extensions to be developed and used.">File Server
Extensions</a> for more information about the file server extension architecture. </p>

<div class="section" id="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-4FEA7E17-8ACE-58E2-B90A-FB2F9BB33766"><a name="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-4FEA7E17-8ACE-58E2-B90A-FB2F9BB33766"><!-- --></a><h2 class="sectiontitle">Developing
an extension</h2><div class="p">This section describes how to use the APIs defined
by the file server to implement a new extension. It contains the following
sections: <ul>
<li><p><a href="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81.html#GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-4CFC2D17-60B9-512F-8896-54AA0F8221CE">Project
file and build</a> describes the requirements for an extension's project
file. </p>
</li>

<li><p><a href="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81.html#GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-7744238A-BFE2-53BD-9B57-D38ED08811EB">Implementing
the factory class</a> describes the factory class that each extension DLL
must implement to create proxy driver objects. </p>
</li>

<li><p><a href="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81.html#GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-6B7F5F60-D50F-5BB0-AB3D-8D065FE5865A">Implementing
the proxy drive extension class</a> describes the proxy drive class that
each extension DLL must implement to provide its extension functionality. </p>
</li>

</ul>
</div>
<p>The examples quoted are taken from the <samp class="codeph">t_logext</samp> test
extension, which is available in the Symbian platform source code at <span class="filepath">os/kernelhwsrv/kerneltest/f32test/ext/t_logext.cpp</span>.
That test code simply logs when the extension functions are called. </p>
 <p id="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-4CFC2D17-60B9-512F-8896-54AA0F8221CE"><a name="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-4CFC2D17-60B9-512F-8896-54AA0F8221CE"><!-- --></a><strong>Project file and build</strong> </p>
<p>A
file server extension is implemented as a polymorphic DLL. Its project file
must be written as follows: </p>
<ul>
<li id="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-8D625BD6-E5D5-53B1-B9D2-634C59DC213F"><a name="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-8D625BD6-E5D5-53B1-B9D2-634C59DC213F"><!-- --></a><p> <samp class="codeph">TARGETTYPE</samp> should
be set to <samp class="codeph">fsy</samp>. This means that the project does not require
a <span class="filepath">.def</span> file to specify its frozen exports: the build
tools will assume the correct frozen exports for the type. </p>
 </li>

<li id="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-66234A27-AB5D-5534-9267-25B65F4821D9"><a name="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-66234A27-AB5D-5534-9267-25B65F4821D9"><!-- --></a><p>The DLL name is conventionally
given the extension <span class="filepath">.fxt</span>. </p>
 </li>

<li id="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-D0718103-1D7B-5926-822E-1CB4B24C68B8"><a name="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-D0718103-1D7B-5926-822E-1CB4B24C68B8"><!-- --></a><p>The second UID should
be <samp class="codeph">0x100039df</samp>. </p>
 </li>

<li id="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-910E63DC-9A65-5124-950B-A7F2BF2929CC"><a name="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-910E63DC-9A65-5124-950B-A7F2BF2929CC"><!-- --></a><p>The DLL is loaded by
the file server, and therefore must have the same platform security capabilities
as that process: <samp class="codeph">TCB ProtServ DiskAdmin AllFiles PowerMgmt CommDD</samp>. </p>
</li>

</ul>
<p>The following shows an example project file: </p>
<pre class="codeblock" id="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-0DAA1B8E-2A55-5942-A166-B09666258967"><a name="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-0DAA1B8E-2A55-5942-A166-B09666258967"><!-- --></a>TARGET            t_logext.fxt
TARGETTYPE        fsy

SOURCEPATH    ../ext
SOURCE            t_logext.cpp

SYSTEMINCLUDE        /epoc32/include 

LIBRARY            euser.lib efile.lib

UID        0x100039df 0x10000CEE
VENDORID 0x70000001

#include "../../f32/group/f32caps.mmh"  // Include capabilities of File Server process</pre>
 <p id="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-7744238A-BFE2-53BD-9B57-D38ED08811EB"><a name="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-7744238A-BFE2-53BD-9B57-D38ED08811EB"><!-- --></a><strong>Implementing the factory
class</strong> </p>
<p>Each extension DLL must implement a factory class that is
responsible for creating proxy driver objects. This is done by implementing
a class derived from <a href="GUID-57D0E9E3-D1B9-36A1-9038-96336F58EA08.html"><span class="apiname">CProxyDriveFactory</span></a>. A pointer to an
object of this class must be returned by the first function exported from
the extension DLL. </p>
<pre class="codeblock" id="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-ABBFEF73-38FE-5689-B89A-FA8207DD2F81"><a name="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-ABBFEF73-38FE-5689-B89A-FA8207DD2F81"><!-- --></a>class CLoggerProxyDriveFactory : public CProxyDriveFactory
    {
public:
    CLoggerProxyDriveFactory();
    virtual TInt Install();            
    virtual CProxyDrive* NewProxyDriveL(CProxyDrive* aProxy,CMountCB* aMount);
    };

...

// Create a new factory
EXPORT_C CProxyDriveFactory* CreateFileSystem()
    {
    return(new CLoggerProxyDriveFactory());
    }
</pre>
 <p><strong>Factory
initialisation </strong> </p>
 <p> <samp class="codeph">CProxyDriveFactory</samp> defines a
pure virtual function <samp class="codeph">Install()</samp> that is called once by the
file server before any other factory object function. You must implement this
to do any required setup. <samp class="codeph">CProxyDriveFactory</samp> is derived from <a href="GUID-578CD638-601C-353D-B1C4-557C72A00DF1.html"><span class="apiname">CFsObject</span></a>,
which means that the file server maintains a reference count of its use, and
allows clients to refer to the object through a name (a string). The <samp class="codeph">Install()</samp> function's
implementation should set the extension's name: </p>
<pre class="codeblock" id="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-ACF692BF-8C52-5430-80C6-9702EFD0FB7D"><a name="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-ACF692BF-8C52-5430-80C6-9702EFD0FB7D"><!-- --></a>TInt CLoggerProxyDriveFactory::Install()
    {
    _LIT(KLoggerName,"Logger");
    return(SetName(&amp;KLoggerName));
    }
</pre>
 <p>Clients can get the name of an extension using <a href="GUID-E263C747-946F-35AA-9F1D-41833BD350FC.html#GUID-E263C747-946F-35AA-9F1D-41833BD350FC__GUID-F00D3D91-212A-3192-8A2E-989912AAA9DD"><span class="apiname">RFs::ExtensionName()</span></a>,
and then use it to specify the extension in functions such as <a href="GUID-E263C747-946F-35AA-9F1D-41833BD350FC.html#GUID-E263C747-946F-35AA-9F1D-41833BD350FC__GUID-5003658C-C5A0-39F0-A518-65B20CD41567"><span class="apiname">RFs::MountExtension()</span></a>. </p>
<p><samp class="codeph">CProxyDriveFactory</samp> also defines a virtual function <samp class="codeph">Remove()</samp>, which is called
just before when the factory object is destroyed. You can override this to
do any required cleanup. </p>
 <p><strong>Proxy drive factory </strong> </p>
<p><samp class="codeph">CProxyDriveFactory</samp> defines
a pure virtual function <samp class="codeph">NewProxyDriveL()</samp> that is called by
the file server to obtain a new proxy drive extension object. You must implement
this to create the proxy drive extension. </p>
<pre class="codeblock" id="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-77B7A963-83D7-5D80-9374-53D296E2248B"><a name="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-77B7A963-83D7-5D80-9374-53D296E2248B"><!-- --></a>CProxyDrive* CLoggerProxyDriveFactory::NewProxyDriveL(CProxyDrive* aProxy,CMountCB* aMount)
    {
    return(CLoggerExtProxyDrive::NewL(aProxy,aMount));
    }</pre>
<p>The <samp class="codeph">aProxy</samp> argument represents the last
extension to be mounted. The new extension will be mounted on top of it. <samp class="codeph">aProxy</samp> could
be an object from another extension library, or a file server <samp class="codeph">CLocalProxyDrive</samp> object
that calls the media sub-system. </p>
<p><samp class="codeph">aMount</samp> represents
the mounted drive to which the extension is being added. </p>
<p><samp class="codeph">aProxy</samp> and <samp class="codeph">aMount</samp> are
required by the proxy drive extension base class (<samp class="codeph">CBaseExtProxyDrive</samp>)
constructor: </p>
<pre class="codeblock" id="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-EF379FC2-F2A5-5F47-8BA6-2C286DF746FA"><a name="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-EF379FC2-F2A5-5F47-8BA6-2C286DF746FA"><!-- --></a>CLoggerExtProxyDrive::CLoggerExtProxyDrive(CProxyDrive* aProxyDrive, CMountCB* aMount)
    :CBaseExtProxyDrive(aProxyDrive,aMount)
    {
    ...
    }</pre>
<p>The arguments are used to initialise private data in <samp class="codeph">CBaseExtProxyDrive</samp>. </p>
 <p><strong>DLL's first exported function</strong></p>
<p>The DLL's first exported function
should create a new instance of the factory class: </p>
<pre class="codeblock" id="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-9173B82F-90BA-5FBD-9EC9-FA7EB08E3794"><a name="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-9173B82F-90BA-5FBD-9EC9-FA7EB08E3794"><!-- --></a>EXPORT_C CProxyDriveFactory* CreateFileSystem()
//
// Create a new file system
//
    {
    return(new CLoggerProxyDriveFactory());
    }</pre>
 <p id="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-6B7F5F60-D50F-5BB0-AB3D-8D065FE5865A"><a name="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-6B7F5F60-D50F-5BB0-AB3D-8D065FE5865A"><!-- --></a><strong>Implementing the proxy drive
extension class</strong> </p>
<p>An extension DLL must contain a proxy drive class
that implements the extension. This is done by implementing a class derived
from <a href="GUID-FAFF712B-2295-3907-B839-D77F052160DA.html"><span class="apiname">CBaseExtProxyDrive</span></a>. <samp class="codeph">CBaseExtProxyDrive</samp> defines
virtual functions that are called by the file system to handle requests such
as reading and writing data from the drive. The functions have default implementations
that simply pass on the request to the media driver, or possibly, to another
extension if one is installed. Your derived class implementation can override
these functions to modify this default functionality. Such a function implementation
typically performs its particular functionality, then calls the corresponding
base class function to pass on the request to the media driver. </p>
<p>The
sequence of calls made to the extension, and the format of the data passed
in those calls, vary according to the file system type. Therefore, to implement
a file system extension you need a good understanding of the particular file
system for which the extension is targeted. </p>
 <p><strong>Initialisation</strong> </p>
<p>The file server calls the proxy drive class <a href="GUID-E735AB4A-E9D5-33C7-ACEC-815013C0777A.html"><span class="apiname">Initialise()</span></a> function
after construction. You can override this function to do any set up you require.
Your implementation should end by calling the base class function <a href="GUID-FAFF712B-2295-3907-B839-D77F052160DA.html#GUID-FAFF712B-2295-3907-B839-D77F052160DA__GUID-0B9ABB2C-6B33-389C-9FF9-04A4799682D9"><span class="apiname">CBaseExtProxyDrive::Initialise()</span></a> to
pass on the request. </p>
<pre class="codeblock" id="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-B52DB6C7-1A2E-516F-A6EB-14A71B2E7BF3"><a name="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-B52DB6C7-1A2E-516F-A6EB-14A71B2E7BF3"><!-- --></a>TInt CLoggerExtProxyDrive::Initialise()
    {
    // extension specific initialisation 
    // ...
    return(CBaseExtProxyDrive::Initialise());
    }</pre>
<p>The file system may at initialisation and at later times
request capability information from the drive using the <samp class="codeph">Caps()</samp> function: </p>
<pre class="codeblock" id="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-9436817E-396D-57D8-A7D7-BE6060DA0C32"><a name="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-9436817E-396D-57D8-A7D7-BE6060DA0C32"><!-- --></a>TInt Caps(TDes8 &amp;anInfo);</pre>
<p>On
return, <samp class="codeph">anInfo</samp> is a packaged capability structure, as defined
in <span class="filepath">d32locd.h</span>. <samp class="codeph">CBaseExtProxyDrive</samp> implements <samp class="codeph">Caps()</samp> to
get the capabilities from the drive. </p>
<p><strong> Cleanup</strong> </p>
<p>If the drive is dismounted, the extension is notified by a call to
its <samp class="codeph">Dismounted()</samp> function, and the proxy drive object is
deleted. </p>
<p><strong>Reading
data from the drive</strong> </p>
<p>A file system requests to read data from the
drive by calling the proxy drive's virtual <samp class="codeph">Read()</samp> functions,
of which there are three overloads. A proxy drive extension can override these
functions to modify the read functionality. The implementation should as usual
pass on the request to the drive using the base class's functions. </p>
<pre class="codeblock" id="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-45E9CADA-5278-59D2-91B4-C6C687730642"><a name="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-45E9CADA-5278-59D2-91B4-C6C687730642"><!-- --></a>TInt CLoggerExtProxyDrive::Read(TInt64 aPos,TInt aLength,TDes8&amp; aTrg)
    {
    // do extension specific operations
    // ...
    return(CBaseExtProxyDrive::Read(aPos,aLength,aTrg));
    }
</pre>
<p><strong>Writing
data to the drive</strong> </p>
<p>A file system requests to write data to the drive
by calling the proxy drive's virtual <samp class="codeph">Write()</samp> functions, of
which there are three overloads. A proxy drive extension can override these
functions to modify the write functionality. The implementation should as
usual pass on the request to the drive using the base class function. </p>
<pre class="codeblock" id="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-BA726003-1033-5609-84CE-61747F6EA287"><a name="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-BA726003-1033-5609-84CE-61747F6EA287"><!-- --></a>TInt CLoggerExtProxyDrive::Write(TInt64 aPos,const TDesC8&amp; aSrc)
    {
    // do extension specific operations
    // ...
    return(CBaseExtProxyDrive::Write(aPos,aSrc));
    }
</pre>
<p>It is possible for some media, such as a RAM disk type drive,
to be dynamically resized to fit the data being written to it. The proxy drive
interface's <samp class="codeph">Enlarge()</samp> and <samp class="codeph">ReduceSize()</samp> functions
handle such resizing requests. An extension can override these functions if
required. </p>
<p><strong>Formatting
a drive</strong> </p>
<p>A file system requests to format a drive by calling the
proxy drive's virtual <a href="GUID-A13BA97D-AB50-30C9-B0A6-51EFCD1A93D6.html"><span class="apiname">Format()</span></a> functions, of which there
are two overloads. A proxy drive extension can override these functions to
modify the drive format functionality. The implementations should as usual
pass on the request to the drive using the base class functions. </p>
<p><strong>Password and drive locking</strong> </p>
<p>Some drive types can be locked using
a password, using functions such as <a href="GUID-E263C747-946F-35AA-9F1D-41833BD350FC.html#GUID-E263C747-946F-35AA-9F1D-41833BD350FC__GUID-1FFBA354-A069-36D4-BEFF-0BD5CCF125E1"><span class="apiname">RFs::LockDrive()</span></a>. The
proxy drive class defines a number of functions, <a href="GUID-5BCEAABF-D060-3F29-A8AE-0C14A8DFC1D2.html"><span class="apiname">Clear()</span></a>, <a href="GUID-216F09C2-60A8-3E42-B466-5D47233E125B.html"><span class="apiname">ErasePassword()</span></a>, <a href="GUID-55300467-B647-3CAC-899E-AF7D2A6C1792.html"><span class="apiname">Lock()</span></a>,
and <a href="GUID-17D8CCBA-9880-3E8D-B58F-7869218AF986.html"><span class="apiname">Unlock()</span></a>, to handle such requests. Extensions can override
these functions and should pass on the request to the drive using the base
class functions. </p>
<p><strong>Error
information</strong> </p>
<p>File systems can in some circumstances request information
from the media driver about the last error that occurred. The proxy drive
class defines the function <a href="GUID-46546BBB-46C0-3AA7-A6F5-CD68A24EF5E9.html"><span class="apiname">GetLastErrorInfo()</span></a> to handle
such requests. Extensions can override this function or use the default implementation
provided by the base class. The error information is a packaged <samp class="codeph">TErrorInfo</samp> structure. </p>
<p><strong>Extension functions</strong> </p>
<p>The proxy drive class implements the common
Symbian platform pattern that allows new functionality to be added to an existing
class without altering the interface, which could cause a compatibility break.
The <samp class="codeph">GetInterface()</samp> function takes an ID argument indicating
the functionality being requested, and generic input and output arguments.
An extension can override this if required. </p>
<pre class="codeblock" id="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-3C50ABD5-D485-5BC5-8D34-0FA40E78BF6A"><a name="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-3C50ABD5-D485-5BC5-8D34-0FA40E78BF6A"><!-- --></a>TInt CLoggerExtProxyDrive::GetInterface(TInt aInterfaceId,TAny*&amp; aInterface,TAny* aInput)
    {
    switch(aInterfaceId)
        {
        // file caching supported, so pass query on to next extension
        case ELocalBufferSupport:
            return CBaseExtProxyDrive::LocalBufferSupport();

        default:
            return CBaseExtProxyDrive::GetInterface(aInterfaceId, aInterface, aInput);
        }
    }</pre>
 <p><strong>Test
operations</strong> </p>
<p>The file server offers an interface, <a href="GUID-E263C747-946F-35AA-9F1D-41833BD350FC.html#GUID-E263C747-946F-35AA-9F1D-41833BD350FC__GUID-DEB7A7A9-7E75-3F6A-9C20-2E5FC8FB6128"><span class="apiname">RFs::ControlIo()</span></a>,
that allows a message to be sent to a media driver in debug builds, in order
to simplify writing test programs. </p>
<p>The proxy drive class defines the
function <a href="GUID-446113DA-8032-375C-9000-16C8E6704E67.html"><span class="apiname">ControlIO()</span></a> to handle such requests. Extensions
can override this function or use the default implementation provided by the
base class. </p>
</div>

<div class="section" id="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-9E7099C2-9A97-503A-B8D7-ADD8A66C8D59"><a name="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-9E7099C2-9A97-503A-B8D7-ADD8A66C8D59"><!-- --></a><h2 class="sectiontitle">Deploying and
using an extension</h2><p>An extension library is only called after a client
has requested the file server to load the extension library and to mount it
on a particular drive. This section first describes how to do this at the
same time as mounting the target file system, and then how to add an extension
to an already mounted file system. </p>
 <p><strong>Mounting
extensions in the Base Starter</strong> </p>
<p>To mount a primary extension, modify
the <a href="GUID-80698E62-E310-59CA-A524-5CF44C437BE4.html" title="The Base Starter is a program that runs when the system starts.">Base Starter</a> to
use the <a href="GUID-EDED466A-BBD8-30E7-A50D-3A0631B73AE9.html"><span class="apiname">RFs:AddExtension()</span></a> and <a href="GUID-9CE6C690-F1C4-329C-B9AF-84A8FAB3E1F0.html"><span class="apiname">RFs:MountFileSystem()</span></a> functions
as shown below. </p>
<pre class="codeblock" id="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-F3802A21-365A-5291-A57F-856B11FCEC81"><a name="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-F3802A21-365A-5291-A57F-856B11FCEC81"><!-- --></a>// If an extension is required, assume its name is set in iExtName
if (iExtName)
    {
    TPtrC extname(iExtName);
    r=iFs.AddExtension(extname);
    if (r==KErrNone || r==KErrAlreadyExists)
    r=iFs.MountFileSystem(fileSysName,extname,drive);
    }
else
                r=iFs.MountFileSystem(fileSysName,drive);</pre>
 <p><a href="GUID-E263C747-946F-35AA-9F1D-41833BD350FC.html#GUID-E263C747-946F-35AA-9F1D-41833BD350FC__GUID-0754C075-92B6-37B3-8959-61D8D65DB491"><span class="apiname">RFs::MountFileSystem()</span></a> can
be passed a flag to specify whether the drive is mounted as synchronous or
asynchronous. An asynchronous drive has its own processing thread, i.e. operations
on it do not block the file server and other drives. A synchronous drive's
requests are processed by the main file server thread and it is possible to
block it with operations on other drives. A drive should be mounted as synchronous
if it is very fast, such an internal RAM or ROFS drive.</p>
<p> <a href="GUID-E263C747-946F-35AA-9F1D-41833BD350FC.html#GUID-E263C747-946F-35AA-9F1D-41833BD350FC__GUID-7546C0FA-4FD4-3C3D-B9E5-92F371759A4B"><span class="apiname">RFs::DismountFileSystem()</span></a> is
used to dismount a file system and any primary and secondary extensions mounted
on the drive. </p>
<p>No resources can be open on the drive while an extension
is mounted as this operation involves a dismount/remount. If the remount fails,
then the extension is dismounted from the drive. </p>
 <p><strong>Mounting by client-side request</strong> </p>
<p>The functions in the file server
client API allow extensions to be managed by file server clients. </p>
<p>Most
of these functions require the name of the extension. Use <a href="GUID-E263C747-946F-35AA-9F1D-41833BD350FC.html#GUID-E263C747-946F-35AA-9F1D-41833BD350FC__GUID-F00D3D91-212A-3192-8A2E-989912AAA9DD"><span class="apiname">RFs::ExtensionName()</span></a> to
get the name of an extension on the specified drive at position <samp class="codeph">aPos</samp>.
The position is the location in the extension chain, the first extension added
is equal to zero. If an extension is not found at <samp class="codeph">aPos</samp> then <samp class="codeph">KErrNotFound</samp> is
returned. </p>
<pre class="codeblock" id="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-C435F3B8-635D-56EB-BCEE-E4EE4CF390DC"><a name="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-C435F3B8-635D-56EB-BCEE-E4EE4CF390DC"><!-- --></a>const TInt KMaxFileSystemExtNameLength = 100; // Arbitrary length
TBuf&lt;KMaxFileSystemExtNameLength&gt; fsExtName;
r = TheFs.ExtensionName(fsExtName, driveNo, 0);</pre>
<p>To mount a secondary
extension it must first be added to the file server using <a href="GUID-E263C747-946F-35AA-9F1D-41833BD350FC.html#GUID-E263C747-946F-35AA-9F1D-41833BD350FC__GUID-D45FD363-EEF9-3F77-8FA1-49270D8E89A0"><span class="apiname">RFs::AddExtension()</span></a>.
This loads the specified extension and adds it to the extension container
in the file server. The extension can then be mounted onto the specified drive
using <a href="GUID-E263C747-946F-35AA-9F1D-41833BD350FC.html#GUID-E263C747-946F-35AA-9F1D-41833BD350FC__GUID-5003658C-C5A0-39F0-A518-65B20CD41567"><span class="apiname">RFs::MountExtension()</span></a>. </p>
<p>To dismount an extension
from a specified drive, use <a href="GUID-E263C747-946F-35AA-9F1D-41833BD350FC.html#GUID-E263C747-946F-35AA-9F1D-41833BD350FC__GUID-D8D25E61-6480-30A0-9A3E-BE7A28FD896C"><span class="apiname">RFs::DismountExtension()</span></a>. This
can only dismount extensions that were mounted using <a href="GUID-E263C747-946F-35AA-9F1D-41833BD350FC.html#GUID-E263C747-946F-35AA-9F1D-41833BD350FC__GUID-5003658C-C5A0-39F0-A518-65B20CD41567"><span class="apiname">RFs::MountExtension()</span></a>.
No resources can be open on the drive when an extension is dismounted. This
operation involves a dismount/remount if there is a current <a href="GUID-FADDE053-CC1C-39BC-A52D-27093041BE20.html"><span class="apiname">CMountCB</span></a> object
mounted on the drive. An extension can be removed from the file server using <a href="GUID-E263C747-946F-35AA-9F1D-41833BD350FC.html#GUID-E263C747-946F-35AA-9F1D-41833BD350FC__GUID-7B8DB8F9-DE75-3FF3-8AE6-1467C3CD4ACF"><span class="apiname">RFs::RemoveExtension()</span></a>. </p>
 </div>

<div class="section" id="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-789DB94B-0650-4FE5-A8B6-312A8A9B499F"><a name="GUID-E10F01A3-6451-52AF-BB35-D93D8D27DD81__GUID-789DB94B-0650-4FE5-A8B6-312A8A9B499F"><!-- --></a><h2 class="sectiontitle">Possible issues with file server extensions</h2><p>Loading
other libraries (such as device drivers and DLLs) from an extension uses the
kernel's loader, which in turn uses the file server. This raises the possibility
of deadlock. Even if your file system extension is for a different file system
than from the one where your driver lives, the loader may still scan other
drives. </p>
<p>Note that <a href="GUID-57D0E9E3-D1B9-36A1-9038-96336F58EA08.html#GUID-57D0E9E3-D1B9-36A1-9038-96336F58EA08__GUID-F3CA0484-A983-31A1-A44C-A067E711E528"><span class="apiname">CProxyDriveFactory::Install()</span></a> is
called from the file server's main thread, so using the file server from there
is guaranteed to deadlock. The simplest solution to this is to have the client
that calls <samp class="codeph">RFs::AddExtension()</samp> load the required library
beforehand. </p>
<p>An alternative approach would be to create
a new thread from the <samp class="codeph">Install()</samp> function and, in order to
load a driver, call <samp class="codeph">User::LoadLogicalDevice()</samp> in that thread.
Your code would need to solve the synchronisation problem of ensuring that
the <samp class="codeph">User::LoadLogicalDevice()</samp> call has completed before attempting
to mount the extension on a drive. </p>
 </div>

</div>
<div>
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a href="GUID-F3BD37EC-0CCB-5859-908F-215E22C9FC20.html" title="The File Server component manages all files on a Symbian platform phone. This section describes how to extend the File Server for your phone hardware.">File Server Extensions</a></div>
</div>
</div>
   
<p class="copyright">Copyright &#169;2010 Nokia Corporation and/or its subsidiary(-ies).<br /> All rights
reserved. Unless otherwise stated, these materials are provided under the terms of the <a href=" http://www.eclipse.org/legal/epl-v10.html"> Eclipse Public License
v1.0</a>.</p> 
</div>
</div>
<?php include_once (CURRENT_SKIN_PATH.'/sdl_footer.html'); ?>

</body>
</html>