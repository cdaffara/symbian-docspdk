<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-us" xml:lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="copyright" content="(C) Copyright 2010"/>
<meta name="DC.rights.owner" content="(C) Copyright 2010"/>
<meta name="DC.Type" content="cxxClass"/>
<meta name="DC.Title" content="MNetworkService"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="GUID-A2D2ECED-00A0-3F8A-8E04-4EE2C049640E"/>

<title>MNetworkService</title>

<link type="text/css" rel="stylesheet" href="css/common.css" media="screen"/>
<link type="text/css" rel="stylesheet" href="css/sdl.css" media="screen"/>

<!--[if IE]>
<link href="css/iefix.css" rel="stylesheet" type="text/css" media="screen" />
<![endif]-->
<meta name="keywords" content="api"/><link rel="stylesheet" type="text/css" href="cxxref.css"/></head>
<body class="cxxref" id="GUID-A2D2ECED-00A0-3F8A-8E04-4EE2C049640E"><a name="GUID-A2D2ECED-00A0-3F8A-8E04-4EE2C049640E"><!-- --></a>


<?php include_once (CURRENT_SKIN_PATH.'/sdl_header.html'); ?>
<div id="sdl_container">
   <div id="leftMenu">  
 <div id="expandcontractdiv">
    <a id="collapseTree" href="javascript:tree.collapseAll()">Collapse all</a>
    <a id="index" href="index.html">Symbian^3 Product Developer Library</a>        
</div>
     <iframe style="border:none" height="800" width="300" src="index-toc.html"></iframe>
<div id="treeDiv1">&#160;</div>
     <script type="text/javascript">
	var currentIconMode = 0; window.name="id2437088 id2437096 id2578593 id2472810 id2408823 id2408865 ";
	YAHOO.util.Event.onDOMReady(buildTree, this,true);
    </script>
     
</div>

<div id="sdl_content">
<div class="breadcrumb"><a href="index.html" title="Symbian^3 Product Developer Library">Symbian^3 Product Developer Library</a> &gt;</div>
<h1 class="topictitle1">MNetworkService Class Reference</h1>
	<table class="signature"><tr><td>class MNetworkService : public MFlowManager</td></tr></table><div class="section"><div>
			<p>Represents the network layer (ip6) of the stack.</p>

			<div class="p">In addition to own functions, the interface encapsulates some often-used <a href="GUID-C8DA9E1C-33A6-33B3-8D75-6B5F6F3BA20F.html#GUID-C8DA9E1C-33A6-33B3-8D75-6B5F6F3BA20F">CProtocolBase</a> functions. For other functions, <a href="GUID-A2D2ECED-00A0-3F8A-8E04-4EE2C049640E.html#GUID-93A0BEE0-4D7E-3195-8C1F-FA43E7072B51">Protocol()</a> gets the real CProtocolBase-derived object, which can be used for other basic functions when required. <dl class="since"><dt class="dlterm">Since</dt>
<dd>v7.0   </dd>
</dl>
</div>

		</div></div>
<div class="section derivation"><h2 class="sectiontitle">Inherits from</h2><ul class="derivation derivation-root"><li class="derivation-depth-0 ">MNetworkService<ul class="derivation"><li class="derivation-depth-1 "><a href="GUID-DBD54C57-13D3-33DA-8B10-F6F3254DAF18.html">MFlowManager</a><ul class="derivation"><li class="derivation-depth-2 "><a href="GUID-8A1D0670-9BB0-3864-B29D-2E6C5E377433.html">MInetBase</a></li></ul></li></ul></li></ul></div>
<div class="section member-index"><table border="0" class="member-index"><thead><tr><th colspan="2">Public Member Functions</th></tr></thead><tbody><tr><td align="right" class="code">void</td><td><a href="#GUID-83C5BB72-484E-3D40-9937-81C83EB8E7C2">BindL</a>(<a href="GUID-C8DA9E1C-33A6-33B3-8D75-6B5F6F3BA20F.html">CProtocolBase</a> *, <a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TUint</a>)</td></tr><tr class="bg"><td align="right" class="code">void</td><td><a href="#GUID-7C20F88B-4729-3A09-9B24-C7D77CE2D9A9">Icmp4Send</a>(<a href="GUID-B4F04621-7932-3D7D-B5B2-5E73F3773B85.html">RMBufRecvPacket</a> &amp;, <a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a>, <a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a>, <a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TUint32</a>, <a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a>)</td></tr><tr><td align="right" class="code">void</td><td><a href="#GUID-16974559-9B8D-3851-9B88-C9B167E460AB">Icmp6Send</a>(<a href="GUID-B4F04621-7932-3D7D-B5B2-5E73F3773B85.html">RMBufRecvPacket</a> &amp;, <a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a>, <a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a>, <a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TUint32</a>, <a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a>)</td></tr><tr class="bg"><td align="right" class="code">
					<a href="GUID-E658D2CE-FCA7-3BEB-A792-0F74440F4851.html">MInterfaceManager</a> *</td><td><a href="#GUID-E527688C-ACA9-3680-9C38-909297CC905C">Interfacer</a>()</td></tr><tr><td align="right" class="code">
					<a href="GUID-7FFBE5D7-A5DD-33D4-BB8D-B9D5C7DD37F5.html">CHostResolvProvdBase</a> *</td><td><a href="#GUID-19BF1CCD-8EEF-340C-ABC3-108CA0B0656B">NewHostResolverL</a>()</td></tr><tr class="bg"><td align="right" class="code">
					<a href="GUID-4C2A1E62-BEE9-39A9-81F4-1D68BA7B1DB4.html">CNetDBProvdBase</a> *</td><td><a href="#GUID-70E0845F-6773-37E1-9F18-F2982E0B15C0">NewNetDatabaseL</a>()</td></tr><tr><td align="right" class="code">
					<a href="GUID-BE5BD662-1AA0-374C-B119-C20327D79112.html">CServiceResolvProvdBase</a> *</td><td><a href="#GUID-F137D892-513A-38BC-B31D-F51A5FCA4FF7">NewServiceResolverL</a>()</td></tr><tr class="bg"><td align="right" class="code">void</td><td><a href="#GUID-7F6980D4-61B3-371B-A665-466C3A22D5D5">Process</a>(<a href="GUID-F024208C-ED19-3301-85C1-53F397C9910F.html">RMBufChain</a> &amp;, <a href="GUID-C8DA9E1C-33A6-33B3-8D75-6B5F6F3BA20F.html">CProtocolBase</a> *)</td></tr><tr><td align="right" class="code">
					<a href="GUID-FB73923D-3D81-3EE7-8C2A-D622B1B702EF.html">CProtocolInet6Binder</a> *</td><td><a href="#GUID-93A0BEE0-4D7E-3195-8C1F-FA43E7072B51">Protocol</a>()</td></tr><tr class="bg"><td align="right" class="code">
					<a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a>
				</td><td><a href="#GUID-E0EE2897-3819-3674-BDD7-B38FA1EB7EB9">Send</a>(<a href="GUID-F024208C-ED19-3301-85C1-53F397C9910F.html">RMBufChain</a> &amp;, <a href="GUID-C8DA9E1C-33A6-33B3-8D75-6B5F6F3BA20F.html">CProtocolBase</a> *)</td></tr></tbody></table><table border="0" class="member-index"><thead><tr><th colspan="2">Inherited Functions</th></tr></thead><tbody><tr><td> </td><td><a href="GUID-DBD54C57-13D3-33DA-8B10-F6F3254DAF18.html">MFlowManager::DecUsers()</a></td></tr><tr class="bg"><td> </td><td><a href="GUID-DBD54C57-13D3-33DA-8B10-F6F3254DAF18.html">MFlowManager::FlowSetupHooks(CFlowInternalContext &amp;)</a></td></tr><tr><td> </td><td><a href="GUID-DBD54C57-13D3-33DA-8B10-F6F3254DAF18.html">MFlowManager::FlowStartRefresh(CFlowInternalContext &amp;)</a></td></tr><tr class="bg"><td> </td><td><a href="GUID-DBD54C57-13D3-33DA-8B10-F6F3254DAF18.html">MFlowManager::GetFlowOption(TUint,TUint,TDes8 &amp;,const CFlowContext &amp;)const</a></td></tr><tr><td> </td><td><a href="GUID-DBD54C57-13D3-33DA-8B10-F6F3254DAF18.html">MFlowManager::IncUsers()</a></td></tr><tr class="bg"><td> </td><td><a href="GUID-DBD54C57-13D3-33DA-8B10-F6F3254DAF18.html">MFlowManager::NewFlowL(const void *,CFlowContext &amp;)</a></td></tr><tr><td> </td><td><a href="GUID-DBD54C57-13D3-33DA-8B10-F6F3254DAF18.html">MFlowManager::NewFlowL(const void *,TUint)</a></td></tr><tr class="bg"><td> </td><td><a href="GUID-DBD54C57-13D3-33DA-8B10-F6F3254DAF18.html">MFlowManager::SetChanged()const</a></td></tr><tr><td> </td><td><a href="GUID-DBD54C57-13D3-33DA-8B10-F6F3254DAF18.html">MFlowManager::SetFlowOption(TUint,TUint,const TDesC8 &amp;,CFlowContext &amp;)</a></td></tr><tr class="bg"><td> </td><td><a href="GUID-8A1D0670-9BB0-3864-B29D-2E6C5E377433.html">MInetBase::GetApiL(const TDesC8 &amp;,TUint *)</a></td></tr><tr><td> </td><td><a href="GUID-8A1D0670-9BB0-3864-B29D-2E6C5E377433.html">MInetBase::GetApiL(const TDesC8 &amp;,TUint)</a></td></tr></tbody></table></div><h1 class="pageHeading topictitle1">Member Functions Documentation</h1><div class="nested1" id="GUID-83C5BB72-484E-3D40-9937-81C83EB8E7C2"><a name="GUID-83C5BB72-484E-3D40-9937-81C83EB8E7C2"><!-- --></a>
		<h2 class="topictitle2">BindL(CProtocolBase *, TUint)</h2>
		<table class="signature"><tr><td>void</td><td>BindL</td><td>(</td><td><a href="GUID-C8DA9E1C-33A6-33B3-8D75-6B5F6F3BA20F.html">CProtocolBase</a> *</td><td>aProtocol,</td></tr><tr><td colspan="3"> </td><td><a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TUint</a></td><td>aId</td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[pure virtual]</td></tr></table><div class="section"><div>
				<p>Binds a protocol or hook to the network layer.</p>

				<p>This is the same as <a href="GUID-C8DA9E1C-33A6-33B3-8D75-6B5F6F3BA20F.html#GUID-BAF129EE-8BBE-32DF-9316-4FA0B37BD4E3">CProtocolBase::BindL</a> implemented in the ip6 protocol.</p>

				<div class="p">This is the primary method of installing a upper layer (or some hook) to the IP layer. The aId determines the type of binding<ul><li><p>aId == 0, invalid</p>
</li>
<li><p>0 &lt; aId &lt;= 255, upper layer bind. The aId is the protocol number as defined for the IPv4 (protocol in <a href="GUID-E55A6E9A-4CED-3B9E-B5E2-1402F7CFE84F.html#GUID-E55A6E9A-4CED-3B9E-B5E2-1402F7CFE84F">TInet6HeaderIP4</a>) or IPv6 (next header in <a href="GUID-70CCCD03-A3EB-3E7D-9B57-807DD6BB6C8A.html#GUID-70CCCD03-A3EB-3E7D-9B57-807DD6BB6C8A">TInet6HeaderIP</a>) header. The bind registers aProtocol as an upper layer receiver of all packets of this protocol. The receiver protocol must be derived from <a href="GUID-C8DA9E1C-33A6-33B3-8D75-6B5F6F3BA20F.html#GUID-C8DA9E1C-33A6-33B3-8D75-6B5F6F3BA20F">CProtocolBase</a> (but see also <a href="GUID-FB73923D-3D81-3EE7-8C2A-D622B1B702EF.html#GUID-FB73923D-3D81-3EE7-8C2A-D622B1B702EF">CProtocolInet6Binder</a>, which can make interfacing easier).</p>
</li>
<li><p>aid &gt; 255, hook bind. The aId determines the type of binding. The bind registers aProtocol as a hook. The hook protocol must be derived from <a href="GUID-A9E16BCD-6D89-3215-BADF-716002B13C47.html#GUID-A9E16BCD-6D89-3215-BADF-716002B13C47">CIp6Hook</a> (but, see <a href="GUID-DDFC307B-F6A1-3D68-9FC4-3E56DABD1BAB.html#GUID-DDFC307B-F6A1-3D68-9FC4-3E56DABD1BAB">CProtocolPosthook</a>, which is derived from <a href="GUID-A9E16BCD-6D89-3215-BADF-716002B13C47.html#GUID-A9E16BCD-6D89-3215-BADF-716002B13C47">CIp6Hook</a> and provides some automatic support for the hook attachment).</p>
</li>
</ul>
</div>

				<p>See also bindl_interface  for more information.</p>

				<p/>

			</div></div>
<div class="section parameters"><h3 class="sectiontitle">Parameters</h3><table border="0" class="parameters"><tr><td class="parameter"><a href="GUID-C8DA9E1C-33A6-33B3-8D75-6B5F6F3BA20F.html">CProtocolBase</a> * aProtocol</td><td>The protocol or hook requesting the bind  </td></tr><tr class="bg"><td class="parameter"><a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TUint</a> aId</td><td>The bind id.  </td></tr></table></div>

	</div>
<div class="nested1" id="GUID-7C20F88B-4729-3A09-9B24-C7D77CE2D9A9"><a name="GUID-7C20F88B-4729-3A09-9B24-C7D77CE2D9A9"><!-- --></a>
		<h2 class="topictitle2">Icmp4Send(RMBufRecvPacket &amp;, TInt, TInt, TUint32, TInt)</h2>
		<table class="signature"><tr><td>void</td><td>Icmp4Send</td><td>(</td><td><a href="GUID-B4F04621-7932-3D7D-B5B2-5E73F3773B85.html">RMBufRecvPacket</a> &amp;</td><td>aPacket,</td></tr><tr><td colspan="3"> </td><td><a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td>aType,</td></tr><tr><td colspan="3"> </td><td><a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td>aCode = 0,</td></tr><tr><td colspan="3"> </td><td><a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TUint32</a></td><td>aParameter = 0,</td></tr><tr><td colspan="3"> </td><td><a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td>aMC = 0</td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[pure virtual]</td></tr></table><div class="section"><div>
				<p>Sends an ICMP (v4) error message based on a received IP packet.</p>

				<p>This function is used to send an ICMP error message based on received IP packet (stored in aPacket). aPacket must begin with the received IP header (either IPv4 or IPv6) at offset 0.</p>

				<p>The aPacket must be in "unpacked state" for the info block (assume RMBufRecvPacket::Unpack() has been called).</p>

				<p>The info block is assumed to be <a href="GUID-4D89D183-0A0C-3FA8-90A9-90FDEC381F8B.html#GUID-4D89D183-0A0C-3FA8-90A9-90FDEC381F8B">RMBufRecvInfo</a>. But, only the following data is significant:</p>

				<div class="p">
					<ul>
						<li>
							<p>
								<a href="GUID-7F08CE77-19F5-3368-8290-45EC6D34B27F.html#GUID-206E83CB-CE60-3E40-B757-C1B3318FB58A">RMBufPktInfo::iFlags</a> only KIpNeverIcmpError flag is tested, and if non-zero, then no ICMP error will be generated, and packet is just dropped. </p>

						</li>

						<li>
							<p>
								<a href="GUID-4D89D183-0A0C-3FA8-90A9-90FDEC381F8B.html#GUID-B91E57C9-2EFE-3153-9560-224C7DB2310B">RMBufRecvInfo::iIcmp</a> must be ZERO. If non-zero, no ICMP error will be generated, and packet is just dropped. A non-zero iIcmp indicates that the received packet itself is being processed as an ICMP error message, and no ICMP error should be generated from ICMP error. </p>

						</li>

						<li>
							<p>
								<a href="GUID-4D89D183-0A0C-3FA8-90A9-90FDEC381F8B.html#GUID-EACB8351-7AA7-3F57-8160-1FCBE7ED5CCA">RMBufRecvInfo::iInterfaceIndex</a> identifies the interface of the received packet. The ICMP error message is normally sent to the incoming interface. For any received packet, this field is properly initialized and should not be touched. If an ICMP error is to be generated from an outgoing packet for which no source interface is known, one can use ZERO here. </p>

						</li>

						<li>
							<p>all other fields are ignored. The source and destination addresses for the ICMP error message are constructed from the IP header of the packet. The addresses in the info block are ignored.</p>

						</li>

					</ul>

				</div>

			</div></div>
<div class="section parameters"><h3 class="sectiontitle">Parameters</h3><table border="0" class="parameters"><tr><td class="parameter"><a href="GUID-B4F04621-7932-3D7D-B5B2-5E73F3773B85.html">RMBufRecvPacket</a> &amp; aPacket</td><td>The received packet for which the ICMP error is being generated. This must start with correct IP header (either IPv4 or IPv6) at offset 0. (The RMbufRecvInfo::iOffset is ignored, and has no significance). The buffer is "consumed" by the call, caller does not need to call Free() for the Packet.  </td></tr><tr class="bg"><td class="parameter"><a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a> aType</td><td>The type of the ICMP [0..255]  </td></tr><tr><td class="parameter"><a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a> aCode = 0</td><td>The code of the ICMP [0..255]  </td></tr><tr class="bg"><td class="parameter"><a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TUint32</a> aParameter = 0</td><td>The parameter value of the ICMP.  </td></tr><tr><td class="parameter"><a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a> aMC = 0</td><td>If non-zero, send ICMP even if the original packet was sent to a multicast or broadcast address. Normally, ICMP error messages are not generated from multicast packets.  </td></tr></table></div>

	</div>
<div class="nested1" id="GUID-16974559-9B8D-3851-9B88-C9B167E460AB"><a name="GUID-16974559-9B8D-3851-9B88-C9B167E460AB"><!-- --></a>
		<h2 class="topictitle2">Icmp6Send(RMBufRecvPacket &amp;, TInt, TInt, TUint32, TInt)</h2>
		<table class="signature"><tr><td>void</td><td>Icmp6Send</td><td>(</td><td><a href="GUID-B4F04621-7932-3D7D-B5B2-5E73F3773B85.html">RMBufRecvPacket</a> &amp;</td><td>aPacket,</td></tr><tr><td colspan="3"> </td><td><a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td>aType,</td></tr><tr><td colspan="3"> </td><td><a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td>aCode = 0,</td></tr><tr><td colspan="3"> </td><td><a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TUint32</a></td><td>aParameter = 0,</td></tr><tr><td colspan="3"> </td><td><a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td>aMC = 0</td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[pure virtual]</td></tr></table><div class="section"><div>
				<p>Sends an ICMP (v6) error message based on a received IP packet.</p>

				<p>See documentation on the <a href="GUID-A2D2ECED-00A0-3F8A-8E04-4EE2C049640E.html#GUID-7C20F88B-4729-3A09-9B24-C7D77CE2D9A9">MNetworkService::Icmp4Send</a> method for the parameters. </p>

			</div></div>
<div class="section parameters"><h3 class="sectiontitle">Parameters</h3><table border="0" class="parameters"><tr><td class="parameter"><a href="GUID-B4F04621-7932-3D7D-B5B2-5E73F3773B85.html">RMBufRecvPacket</a> &amp; aPacket</td><td> </td></tr><tr class="bg"><td class="parameter"><a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a> aType</td><td> </td></tr><tr><td class="parameter"><a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a> aCode = 0</td><td> </td></tr><tr class="bg"><td class="parameter"><a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TUint32</a> aParameter = 0</td><td> </td></tr><tr><td class="parameter"><a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a> aMC = 0</td><td> </td></tr></table></div>

	</div>
<div class="nested1" id="GUID-E527688C-ACA9-3680-9C38-909297CC905C"><a name="GUID-E527688C-ACA9-3680-9C38-909297CC905C"><!-- --></a>
		<h2 class="topictitle2">Interfacer()</h2>
		<table class="signature"><tr><td>
					<a href="GUID-E658D2CE-FCA7-3BEB-A792-0F74440F4851.html">MInterfaceManager</a> *</td><td>Interfacer</td><td>(</td><td>)</td><td>const [pure virtual]</td></tr></table><div class="section"><div>
				<p>Gets the interface manager for the network layer (ip6) of the stack. </p>

			</div></div>

	</div>
<div class="nested1" id="GUID-19BF1CCD-8EEF-340C-ABC3-108CA0B0656B"><a name="GUID-19BF1CCD-8EEF-340C-ABC3-108CA0B0656B"><!-- --></a>
		<h2 class="topictitle2">NewHostResolverL()</h2>
		<table class="signature"><tr><td>
					<a href="GUID-7FFBE5D7-A5DD-33D4-BB8D-B9D5C7DD37F5.html">CHostResolvProvdBase</a> *</td><td>NewHostResolverL</td><td>(</td><td>)</td><td>[pure virtual]</td></tr></table><div class="section"><div>
				<p>Gets the default name services provider from the network layer.</p>

				<p>The network layer (IP) provides a gateway to the name resolver implementation for DNS.</p>

				<p>In EPOC, each protocol is responsible for implementing it's own name resolution. Any protocol wishing to support RhostResolver can get the full DNS support from the network layer by just delegating the call via this method.</p>

				<p/>

			</div></div>

	</div>
<div class="nested1" id="GUID-70E0845F-6773-37E1-9F18-F2982E0B15C0"><a name="GUID-70E0845F-6773-37E1-9F18-F2982E0B15C0"><!-- --></a>
		<h2 class="topictitle2">NewNetDatabaseL()</h2>
		<table class="signature"><tr><td>
					<a href="GUID-4C2A1E62-BEE9-39A9-81F4-1D68BA7B1DB4.html">CNetDBProvdBase</a> *</td><td>NewNetDatabaseL</td><td>(</td><td>)</td><td>[pure virtual]</td></tr></table><div class="section"><div>
				<p>Gets the default net database provider from the network layer. Not supported, always leaves. </p>

			</div></div>

	</div>
<div class="nested1" id="GUID-F137D892-513A-38BC-B31D-F51A5FCA4FF7"><a name="GUID-F137D892-513A-38BC-B31D-F51A5FCA4FF7"><!-- --></a>
		<h2 class="topictitle2">NewServiceResolverL()</h2>
		<table class="signature"><tr><td>
					<a href="GUID-BE5BD662-1AA0-374C-B119-C20327D79112.html">CServiceResolvProvdBase</a> *</td><td>NewServiceResolverL</td><td>(</td><td>)</td><td>[pure virtual]</td></tr></table><div class="section"><div>
				<p>Gets the default service resolver provider from the network layer. Not supported, always leaves. </p>

			</div></div>

	</div>
<div class="nested1" id="GUID-7F6980D4-61B3-371B-A665-466C3A22D5D5"><a name="GUID-7F6980D4-61B3-371B-A665-466C3A22D5D5"><!-- --></a>
		<h2 class="topictitle2">Process(RMBufChain &amp;, CProtocolBase *)</h2>
		<table class="signature"><tr><td>void</td><td>Process</td><td>(</td><td><a href="GUID-F024208C-ED19-3301-85C1-53F397C9910F.html">RMBufChain</a> &amp;</td><td>aPacket,</td></tr><tr><td colspan="3"> </td><td><a href="GUID-C8DA9E1C-33A6-33B3-8D75-6B5F6F3BA20F.html">CProtocolBase</a> *</td><td>aSource = NULL</td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[pure virtual]</td></tr></table><div class="section"><div>
				<p>Processes incoming packet.</p>

				<p>This is a direct accesss to the IP layer <a href="GUID-C8DA9E1C-33A6-33B3-8D75-6B5F6F3BA20F.html#GUID-62A99C64-72DA-3263-8E52-1B540854E619">CProtocolBase::Process</a> function.</p>

				<div class="p">The IP layer <a href="GUID-C8DA9E1C-33A6-33B3-8D75-6B5F6F3BA20F.html#GUID-62A99C64-72DA-3263-8E52-1B540854E619">CProtocolBase::Process</a> is the function used by NIFs to feed in packets from the link layer. The aSource must be a CNifIfBase derived object and known to the interface manager of the stack. Otherwise the IP layer will not accept the packet. The passed packet must follow the rules as described in nif_inbound_packets  The packet goes through the following process:<ol><li><p>the packet is pushed through the inbound posthooks as is (for example, see <a href="GUID-DDFC307B-F6A1-3D68-9FC4-3E56DABD1BAB.html#GUID-ADE6A491-A552-30F2-8D8F-C3472B71B6AE">CProtocolPosthook::Process</a>), and then queued for IP processing.</p>
</li>
<li><p>the packet from the queue is processed as an IP packet and extension headers are processed by inbound hooks (<a href="GUID-43799E3E-A0D3-3CEF-B925-892960FA1251.html#GUID-0A9A9CE8-3EA4-3EAD-92B2-DA0E784DCA66">MIp6Hook::ApplyL</a>)</p>
</li>
<li><p>the packet is passed to the upper layer protcool (<a href="GUID-C8DA9E1C-33A6-33B3-8D75-6B5F6F3BA20F.html#GUID-62A99C64-72DA-3263-8E52-1B540854E619">CProtocolBase::Process</a>)</p>
</li>
</ol>
</div>

				<p>If any hook or protocol in the inbound path decides to use this function to re-inject a (modified) packet back to the system, then it must remove the packet from the current inbound processing path. </p>

			</div></div>
<div class="section parameters"><h3 class="sectiontitle">Parameters</h3><table border="0" class="parameters"><tr><td class="parameter"><a href="GUID-F024208C-ED19-3301-85C1-53F397C9910F.html">RMBufChain</a> &amp; aPacket</td><td>The packet  </td></tr><tr class="bg"><td class="parameter"><a href="GUID-C8DA9E1C-33A6-33B3-8D75-6B5F6F3BA20F.html">CProtocolBase</a> * aSource = NULL</td><td>The source of the packet (a NIF) </td></tr></table></div>

	</div>
<div class="nested1" id="GUID-93A0BEE0-4D7E-3195-8C1F-FA43E7072B51"><a name="GUID-93A0BEE0-4D7E-3195-8C1F-FA43E7072B51"><!-- --></a>
		<h2 class="topictitle2">Protocol()</h2>
		<table class="signature"><tr><td>
					<a href="GUID-FB73923D-3D81-3EE7-8C2A-D622B1B702EF.html">CProtocolInet6Binder</a> *</td><td>Protocol</td><td>(</td><td>)</td><td>const [pure virtual]</td></tr></table><div class="section"><div>
				<p>Gets the underlying protocol object for the network layer (ip6) of the stack. </p>

			</div></div>

	</div>
<div class="nested1" id="GUID-E0EE2897-3819-3674-BDD7-B38FA1EB7EB9"><a name="GUID-E0EE2897-3819-3674-BDD7-B38FA1EB7EB9"><!-- --></a>
		<h2 class="topictitle2">Send(RMBufChain &amp;, CProtocolBase *)</h2>
		<table class="signature"><tr><td>
					<a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a>
				</td><td>Send</td><td>(</td><td><a href="GUID-F024208C-ED19-3301-85C1-53F397C9910F.html">RMBufChain</a> &amp;</td><td>aPacket,</td></tr><tr><td colspan="3"> </td><td><a href="GUID-C8DA9E1C-33A6-33B3-8D75-6B5F6F3BA20F.html">CProtocolBase</a> *</td><td>aSource = NULL</td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[pure virtual]</td></tr></table><div class="section"><div>
				<p>Sends outgoing packet.</p>

				<p>This is a direct access to the IP layer <a href="GUID-C8DA9E1C-33A6-33B3-8D75-6B5F6F3BA20F.html#GUID-16A9B085-2ABB-3B4E-BB69-4FD186358986">CProtocolBase::Send</a> function.</p>

				<p>The IP layer <a href="GUID-C8DA9E1C-33A6-33B3-8D75-6B5F6F3BA20F.html#GUID-16A9B085-2ABB-3B4E-BB69-4FD186358986">CProtocolBase::Send</a> is the function used by upper layer protocols to feed in packet to the IP layer. This packet does not normally have the IPv6 or IPv4 headers (unless the <a href="GUID-2CB64551-4879-3565-9835-6EDF8116B9A7.html#GUID-E287E3AE-A4D7-3326-AD9D-415775BA4315">KIpHeaderIncluded</a> flag is set the iFlags), and the packet begins directly with the upper layer protocol header (for example TInet6HeaderUDP or <a href="GUID-FF5E68D5-3352-380F-A0E7-A00CF0659879.html#GUID-FF5E68D5-3352-380F-A0E7-A00CF0659879">TInet6HeaderTCP</a>).</p>

				<div class="p">The information block is <a href="GUID-B0F9F6A7-6D70-3B70-9981-46516281FCA9.html#GUID-B0F9F6A7-6D70-3B70-9981-46516281FCA9">RMBufSendInfo</a>, which extends the basic <a href="GUID-7F08CE77-19F5-3368-8290-45EC6D34B27F.html#GUID-7F08CE77-19F5-3368-8290-45EC6D34B27F">RMBufPktInfo</a> by <a href="GUID-CB6234B4-19A3-3D9E-AEBE-546D349CDD0D.html#GUID-CB6234B4-19A3-3D9E-AEBE-546D349CDD0D">RFlowContext</a> member. This must be correctly initialized. The three alternatives are <pre class="codeblock">	RFlowContext flow;			// some existing flow
	MNetworkService *manager;
	RMBufSendPacket packet;		// unpacked state.
	RMBufSendInfo *info = packet.Info();
	TInt res = KErrNone;

	// 1. No flow context (avoid this if you can)
	info-&gt;iFlow = RFlowContext();

	// 2. A new flow context (assuming the base part of info is already set).
	res = info-&gt;iFlow.Open(manager, info-&gt;iDstAddr, info-&gt;iSrcAddr,
			info-&gt;iProtocol, icmp_type, icmp_code);

	// 3. A reference to existing opened flow (this will load the base part
	// of the info from the attached flow).
	res = info-&gt;iFlow.Open(flow, info);

	// sending the packet.
	if (res == KErrNone)
		{
		aPacket.Pack();
		manager-&gt;Send(aPacket);
		}
	else
		{
		// creation failed (res &lt; 0) or is blocked (res &gt; 0)
		info-&gt;iFlow.Close();
		}
	aPacket.Free();</pre>
 The first two are inefficient. They require a full flow open/close sequence for each packet. The third alternative is the most efficient, because the same flow is re-used for multiple packets. This also enables the use of <a href="GUID-CB6234B4-19A3-3D9E-AEBE-546D349CDD0D.html#GUID-8155AD67-1F94-3474-BDF8-9041D8A77E9E">RFlowContext::SetNotify</a> for asynchronous detection of unblocking or error on the flow.</div>

				<div class="p">The packet goes through the following steps:<ol><li><p>if a flow context is missing, allocate and connect a new flow context for the packet. The flow selectors are based on address and protocol fields of the <a href="GUID-7F08CE77-19F5-3368-8290-45EC6D34B27F.html#GUID-7F08CE77-19F5-3368-8290-45EC6D34B27F">RMBufPktInfo</a> (alternative 2. in above).</p>
</li>
<li><p>if the packet does not have <a href="GUID-2CB64551-4879-3565-9835-6EDF8116B9A7.html#GUID-E287E3AE-A4D7-3326-AD9D-415775BA4315">KIpHeaderIncluded</a> flag set in iFlags of the info, an IPv4 or IPv6 header is added (based on the value of CFlowContext::iHead.ip6.Version()). The content of CFlowContext::iHead.iPacket is copied after the IP header.</p>
</li>
<li><p>the packet is passed through the <a href="GUID-1FED6DB6-237F-353D-9F3D-ADBCD56397C3.html#GUID-81945C07-C847-3685-8C5C-460A2C92BAF8">MFlowHook::ApplyL</a> function of all attached outbound flow hooks.</p>
</li>
<li><p>if the packet is longer than the path MTU, it is fragmented. Unless <a href="GUID-2CB64551-4879-3565-9835-6EDF8116B9A7.html#GUID-E3C8B1CA-FE42-395F-A2FE-D23C345B0856">KIpDontFragment</a> is set. In that case the stack generates an ICMP error message "packet too big".</p>
</li>
<li><p>the packet (or fragments) are passed through all outbound post hooks (for example, <a href="GUID-DDFC307B-F6A1-3D68-9FC4-3E56DABD1BAB.html#GUID-6E571801-9FFA-34E4-918B-2C9053212650">CProtocolPosthook::Send</a>).</p>
</li>
<li><p>the terminator post hook finally passes the packet(s) to the <a href="GUID-86BC510A-9072-3EDD-AD4B-3ABAE616C0B3.html#GUID-4E80837B-A4EC-3479-9DCF-491A352D48C0">CFlowContext::Send</a> function, which eventually passes the packet to the CNifIfBase::Send (the packet may need to be queued for a while due to neighbor discovery, or just because NIF is blocked). (see also nif_outbound_packets  ) </p>
</li>
</ol>
</div>

			</div></div>
<div class="section parameters"><h3 class="sectiontitle">Parameters</h3><table border="0" class="parameters"><tr><td class="parameter"><a href="GUID-F024208C-ED19-3301-85C1-53F397C9910F.html">RMBufChain</a> &amp; aPacket</td><td>The packet  </td></tr><tr class="bg"><td class="parameter"><a href="GUID-C8DA9E1C-33A6-33B3-8D75-6B5F6F3BA20F.html">CProtocolBase</a> * aSource = NULL</td><td>Protocol sending the data. </td></tr></table></div>

	</div>

	
	
	
	
	
	
	
	
	
	
	
   
<p class="copyright">Copyright &#169;2010 Nokia Corporation and/or its subsidiary(-ies).<br /> All rights
reserved. Unless otherwise stated, these materials are provided under the terms of the <a href=" http://www.eclipse.org/legal/epl-v10.html"> Eclipse Public License
v1.0</a>.</p> 
</div>
</div>
<?php include_once (CURRENT_SKIN_PATH.'/sdl_footer.html'); ?>

</body>
</html>