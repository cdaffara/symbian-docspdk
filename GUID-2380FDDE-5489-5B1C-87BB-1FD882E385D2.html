<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="copyright" content="(C) Copyright 2010"/>
<meta name="DC.rights.owner" content="(C) Copyright 2010"/>
<meta name="DC.Type" content="concept"/>
<meta name="DC.Title" content="Migration Tutorial: Direct Memory Addressing"/>
<meta name="abstract" content="To handle direct memory addressing, you must to make the following changes to your code."/>
<meta name="description" content="To handle direct memory addressing, you must to make the following changes to your code."/>
<meta name="DC.Relation" scheme="URI" content="GUID-5C223AD5-4676-58B4-B3A5-066F6B69AA4D.html"/>
<meta name="DC.Relation" scheme="URI" content="index.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-32E29020-1956-461A-B79A-1492E06049E7.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-C14B2552-43A7-4499-ABFE-1725128DA6EF.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-52371DAB-A231-558C-B3E6-220DAAEE566B.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-5C223AD5-4676-58B4-B3A5-066F6B69AA4D.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-86082C0C-B0EE-5E7C-85B4-4A509066012F.html"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2"/>
<meta name="DC.Language" content="en"/>
<link rel="stylesheet" type="text/css" href="commonltr.css"/>
<title>Migration Tutorial: Direct Memory Addressing</title>

     
<link type="text/css" rel="stylesheet" href="css/common.css" media="screen"/>
<link type="text/css" rel="stylesheet" href="css/sdl.css" media="screen"/>

<!--[if IE]>
<link href="css/iefix.css" rel="stylesheet" type="text/css" media="screen" />
<![endif]-->



     <link rel="stylesheet" type="text/css" href="nokiacxxref.css"/></head>
<body id="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2"><a name="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2"><!-- --></a>


<?php include_once (CURRENT_SKIN_PATH.'/sdl_header.html'); ?>
<div id="sdl_container">
   <div id="leftMenu">  
 <div id="expandcontractdiv">
    <a id="collapseTree" href="javascript:tree.collapseAll()">Collapse all</a>
    <a id="index" href="index.html">Symbian^3 Product Developer Library</a>        
</div>
     <iframe style="border:none" height="800" width="300" src="index-toc.html"></iframe>
<div id="treeDiv1">&#160;</div>
     <script type="text/javascript">
	var currentIconMode = 0; window.name="id2563754 id2387835 id2400778 id2402024 ";
	YAHOO.util.Event.onDOMReady(buildTree, this,true);
    </script>
     
</div>

<div id="sdl_content">


<div class="breadcrumb"><a href="index.html" title="Symbian^3 Product Developer Library">Symbian^3 Product Developer Library</a> &gt; <a href="GUID-32E29020-1956-461A-B79A-1492E06049E7.html" title="The Symbian Guide describes the architecture and functionality of the platform, and provides guides on using its APIs.">Symbian Guide</a> &gt; <a href="GUID-C14B2552-43A7-4499-ABFE-1725128DA6EF.html" title="Kernel and Hardware Services performs the fundamental operating system tasks of managing access to device resources.">Kernel and Hardware Services Guide</a> &gt; <a href="GUID-52371DAB-A231-558C-B3E6-220DAAEE566B.html" title="Provides software components that implement the interface between Symbian platform and peripherals.">Logical Device Drivers</a> &gt; <a href="GUID-5C223AD5-4676-58B4-B3A5-066F6B69AA4D.html" title="Provides the logical device driver for the internal and removable storage media on a phone.">Local Media Subsystem</a> &gt; </div>
<h1 class="topictitle1">Migration
Tutorial: Direct Memory Addressing</h1>
<div><p>To handle direct memory addressing, you must to make the following
changes to your code. </p>

<p>If a media driver uses a data transfer mechanism like <a href="GUID-E5576D91-BC5C-588E-BF90-5A1E3C445133.html">DMA</a>,
data transfer can be faster if the media driver knows that an address passed
in an I/O request is a physical address. This is known as direct memory addressing. </p>

<ul>
<li id="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-E2C6E9D0-0150-529C-953E-32DFDEA68E77"><a name="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-E2C6E9D0-0150-529C-953E-32DFDEA68E77"><!-- --></a><p> <a href="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2.html#GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-621EB44F-25BB-5B71-BF74-ED0304B7B591">Changes to registration</a>  </p>
 </li>

<li id="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-62701989-76A6-52D5-A713-226343BED4EE"><a name="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-62701989-76A6-52D5-A713-226343BED4EE"><!-- --></a><p> <a href="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2.html#GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-49992CF9-404A-585C-8770-E9034434A344">Changes to request handling</a>  </p>
 </li>

<li id="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-79FF128E-98B3-5613-B02A-08A81FC5B82D"><a name="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-79FF128E-98B3-5613-B02A-08A81FC5B82D"><!-- --></a><p> <a href="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2.html#GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-5F4A392F-0EAF-5E69-B902-D987B8FFD610">Issues about physical addresses</a>  </p>
 </li>

</ul>

<div class="section" id="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-621EB44F-25BB-5B71-BF74-ED0304B7B591"><a name="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-621EB44F-25BB-5B71-BF74-ED0304B7B591"><!-- --></a><h2 class="sectiontitle">Changes to
registration</h2> <p>If the media driver code can handle physical addresses,
it must tell the local media subsystem. This process is called registration.
The media driver calls <a href="GUID-9E60E8D9-619E-3A76-BAC8-93A60D62C7DF.html#GUID-9E60E8D9-619E-3A76-BAC8-93A60D62C7DF__GUID-57B3380F-3CA6-3FF4-9D79-05B718E0743A"><span class="apiname">LocDrv::RegisterDmaDevice()</span></a> to register
as part of the <a href="GUID-A70A01D2-467E-5BA8-A01D-6182558F3F52.html" title="How to write an initialisation function, implemented by the Media driver and called by the kernel at boot time.">media
driver initialisation</a> process. The media driver calls <samp class="codeph">RegisterDmaDevice()</samp> after
the media driver has <a href="GUID-A70A01D2-467E-5BA8-A01D-6182558F3F52.html#GUID-A70A01D2-467E-5BA8-A01D-6182558F3F52__GUID-4A8DEEAB-32C4-5431-8226-5623E2BD9098">registered
with the local media subsystem</a>. </p>
 <p>After the call to <a href="GUID-9E60E8D9-619E-3A76-BAC8-93A60D62C7DF.html#GUID-9E60E8D9-619E-3A76-BAC8-93A60D62C7DF__GUID-57B3380F-3CA6-3FF4-9D79-05B718E0743A"><span class="apiname">LocDrv::RegisterDmaDevice()</span></a>,
the local media subsystem will test if the address in an I/O request is a
physical address or a virtual address. The local media subsystem extracts
the information that the media driver requires. The media driver gets this
information through calls to the functions: </p>
 <ul>
<li id="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-93AEF5CB-CB70-5369-BC33-9F2B51903FFE"><a name="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-93AEF5CB-CB70-5369-BC33-9F2B51903FFE"><!-- --></a><p> <a href="GUID-D84A9903-AE0F-3F54-8833-E8956A88E26C.html#GUID-D84A9903-AE0F-3F54-8833-E8956A88E26C__GUID-DD6773B4-9EF5-322F-B53D-29174DF3B3BF"><span class="apiname">TLocDrvRequest::IsPhysicalAddress()</span></a>. </p>
 </li>

<li id="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-33328F10-BE3D-5ADA-8FFE-5E19764E43F1"><a name="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-33328F10-BE3D-5ADA-8FFE-5E19764E43F1"><!-- --></a><p> <a href="GUID-D84A9903-AE0F-3F54-8833-E8956A88E26C.html#GUID-D84A9903-AE0F-3F54-8833-E8956A88E26C__GUID-9879145B-D996-327E-87F6-3B8337A86A56"><span class="apiname">TLocDrvRequest::GetNextPhysicalAddress()</span></a>. </p>
 </li>

</ul>
 <p>A <a href="GUID-D84A9903-AE0F-3F54-8833-E8956A88E26C.html"><span class="apiname">TLocDrvRequest</span></a> object represents an I/O request
and is passed to the media driver. </p>
 <p>There are three pieces of information
that the local media subsystem needs from the media driver when the media
driver registers: </p>
 <ul>
<li id="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-7A889D6A-52E0-5FBB-BC2F-A1E10A0F0D4D"><a name="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-7A889D6A-52E0-5FBB-BC2F-A1E10A0F0D4D"><!-- --></a><p>The <em>minimum number
of bytes</em> that the media device can transfer. For example, the architecture
of some memory card types requires data transfer in blocks of 512 bytes. The
local media subsystem can not support I/O requests for physical addresses
where the length of the data is smaller than this minimum number. This limit
prevents accidental access of the data outside the limits of the request. </p>
 </li>

<li id="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-C778CC22-699B-5B01-B217-C6567CBE01E3"><a name="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-C778CC22-699B-5B01-B217-C6567CBE01E3"><!-- --></a><p>The <em>maximum number
of bytes</em> that the media driver can transfer in one burst. This value depends
on the hardware. For eaxample,<a href="GUID-0D2F811C-81C3-526F-8EA4-98E50261BF4B.html" title="Describes the classes that the DMA Framework provides to transfer data using DMA.">DMA
Framework</a> has limits that depend on the DMA controller. </p>
 </li>

<li id="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-49B448A8-B8ED-5EF6-9AB2-BA43FD6ED34F"><a name="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-49B448A8-B8ED-5EF6-9AB2-BA43FD6ED34F"><!-- --></a><p>The <em>alignment of
memory</em> that the DMA controller requires. For example: a DMA controller
might require 2 byte (word or 16 bit) alignment or 4 byte (double word or
32 bit) alignment. For 2 byte alignment, specify 2; for 4 byte alignment specify
4 etc. The local media subsystem can not support I/O requests for physical
addresses that are not aligned according to this value. </p>
 </li>

</ul>
 <p>You get all of this information from the documentation for the platform. </p>
 <p>This
example code extends the code shown in the section <a href="GUID-A70A01D2-467E-5BA8-A01D-6182558F3F52.html" title="How to write an initialisation function, implemented by the Media driver and called by the kernel at boot time.">Media
driver initialisation before the system is initialised</a>. It adds a call
to <a href="GUID-9E60E8D9-619E-3A76-BAC8-93A60D62C7DF.html#GUID-9E60E8D9-619E-3A76-BAC8-93A60D62C7DF__GUID-57B3380F-3CA6-3FF4-9D79-05B718E0743A"><span class="apiname">LocDrv::RegisterDmaDevice()</span></a>. This call follows registration
of the media driver with the local media subsystem. </p>
 <pre class="codeblock" id="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-A56AFE4C-729A-57DA-B232-60A29CE7F735"><a name="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-A56AFE4C-729A-57DA-B232-60A29CE7F735"><!-- --></a>DECLARE_STANDARD_EXTENSION()
    {
    TInt r=KErrNoMemory;
    DPrimaryMediaBase* pM=new DPrimaryMediaBase;
    if (pM)
        {//…Required here for Asynchronous creation (if supported)
        pM-&gt;iDfcQ = &amp;MyDfcQ;
 
        // Perform registration here
        r = LocDrv::RegisterMediaDevice(MEDIA_DEVICE_TYPE,
                                        MEDIA_DRIVECOUNT,
                                        &amp;IMediaDriveNumbers[0],
                                        pM,MEDIA_NUMMEDIA,KMediaDriveName
                                       );
        if ® != KErrNone)
            {
            return r;
            }
       
        // Register support for physical addressing.
        //
        // Note : in practice the values passed to RegisterDmaDevice() would be
        // either symbolic constants or functions that return values. If the 
        // media driver is split into platform independent and platform dependent
        // layers, and this code is in the independent layer, then you will need 
        // functions in the dependent layer to provide these values.
        r = LocDrv::RegisterDmaDevice(pM,
                                                    512,  // Block Addressing 512 Bytes
                                                    1024, // 1024 Byte address range
                                                    2 );  // 2 Byte alignment
        if ® != KErrNone)
            {
            return r;
            }
        ...
        }
    return®);
    }
      </pre>
 </div>

<div class="section" id="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-49992CF9-404A-585C-8770-E9034434A344"><a name="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-49992CF9-404A-585C-8770-E9034434A344"><!-- --></a><h2 class="sectiontitle"> Changes to
request handling</h2> <p>To use physical addreses, you need to make changes
to the code that deals with <samp class="codeph">ERead</samp> and <samp class="codeph">EWrite</samp> requests
in your implementation of the <a href="GUID-EBF025DB-1552-5E99-8C07-09932DB60552.html#GUID-EBF025DB-1552-5E99-8C07-09932DB60552__GUID-EC193360-31C2-5012-8ED2-19F1C48C8FC5">DMediaDriver::Request()</a> function. This section discusses the issues with <samp class="codeph">ERead</samp> requests,
but the principles apply to <samp class="codeph">EWrite</samp> requests. </p>
 <p>There
are a number of points to consider: </p>
 <p><strong>Check if the address is physical </strong> </p>
 <p>Call <a href="GUID-D84A9903-AE0F-3F54-8833-E8956A88E26C.html#GUID-D84A9903-AE0F-3F54-8833-E8956A88E26C__GUID-DD6773B4-9EF5-322F-B53D-29174DF3B3BF"><span class="apiname">TLocDrvRequest::IsPhysicalAddress()</span></a> to
test if the address passed is a physical address. For example, for a <samp class="codeph">ERead</samp> request: </p>
 <pre class="codeblock" id="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-90F1EE30-DAE5-5DE5-B42E-9EF48EB12509"><a name="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-90F1EE30-DAE5-5DE5-B42E-9EF48EB12509"><!-- --></a>...
   // iReadReq points to a TLocDrvRequest object
   ...
   iMediaStartPos = iReadReq-&gt;Pos();
   iTotalLength   = I64LOW(iReadReq-&gt;Length()); 
   iDoPhysicalAddress = iReadReq-&gt;IsPhysicalAddress();
   if(iDoPhysicalAddress)
      {
      ..&lt; Physical address memory code &gt;..
      }
   else
      {
      ...&lt; Virtual address memory code &gt;...</pre>
 <p><strong>Physical address code </strong> </p>
 <p>If you want to use the physical address,
you need to get the physical address and the length of contiguous memory at
this location. Call <a href="GUID-D84A9903-AE0F-3F54-8833-E8956A88E26C.html#GUID-D84A9903-AE0F-3F54-8833-E8956A88E26C__GUID-9879145B-D996-327E-87F6-3B8337A86A56"><span class="apiname">TLocDrvRequest::GetNextPhysicalAddress()</span></a> to
get the physical address and the length of physically contiguous memory. The
length of physically contiguous memory can be smaller than the length supplied
in the read request, because physical memory can be fragmented into a number
of small blocks. If the length is smaller than the length supplied in the
read or write request, you call <a href="GUID-D84A9903-AE0F-3F54-8833-E8956A88E26C.html#GUID-D84A9903-AE0F-3F54-8833-E8956A88E26C__GUID-9879145B-D996-327E-87F6-3B8337A86A56"><span class="apiname">TLocDrvRequest::GetNextPhysicalAddress()</span></a> again
to get the address of the next physically contiguous block of memory. You
repeat this operation until the read request is complete. For example, for
a <samp class="codeph">ERead</samp> request: </p>
 <pre class="codeblock" id="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-2311A626-38BF-582F-B310-8E30D73AA1A7"><a name="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-2311A626-38BF-582F-B310-8E30D73AA1A7"><!-- --></a>...
   // iReadReq points to a TLocDrvRequest object
   ...
   TPhysAddr physAddr; 
   TInt physLength;
   TInt err = KErrNone;                
   err = iReadReq-&gt;GetNextPhysicalAddress(physAddr, physLength);
   if(err == KErrNone)
      {                       
      if (physLength &lt; iTotalLength)
         {
         // Memory is fragmented, note remainder. You will need 
         // to use this code again using the remainder value.
         iRemaining    = iTotalLength – physLength;
         iTotalLength -= physLength;
         }
      
      // Start data transfer into the current physically
      // contiguous block of physical memory.
      DoDataTransfer(iMediaStartPos, physLength, physAddr);
      ...
      }
</pre>
 <p>If you do not want to deal with fragmented physical memory,
you can use your original code. </p>
 <p><strong>Virtual to physical address translation </strong> </p>
 <p>Your code must not
perform a virtual to physical address translation when it deals with physical
memory. For example: </p>
 <pre class="codeblock" id="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-4377A0D5-8E41-59AF-B26E-C468ABAFCF47"><a name="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-4377A0D5-8E41-59AF-B26E-C468ABAFCF47"><!-- --></a>void DMMCRxDmaHelp::ChannelTransfer(const SDmaPseudoDes&amp; aDes)
      {
      …
      TPhysAddr dest;

      if (iCurrentReq-&gt;IsPhysicalAddress())
         dest = (TPhysAddr) aDes.iDest;
      else
         dest = Epoc::LinearToPhysical(aDes.iDest);
      TPlatDma::SetDMARegister(KHoDMA_CDSA(iChno), dest);
      …
      }</pre>
 <p><strong>Eliminate inter-process copy </strong> </p>
 <p>You must change your code to
remove calls to <a href="GUID-D84A9903-AE0F-3F54-8833-E8956A88E26C.html#GUID-D84A9903-AE0F-3F54-8833-E8956A88E26C__GUID-842F91FF-C780-3E2A-8860-8F34815452FC"><span class="apiname">TLocDrvRequest::WriteRemote()</span></a>. For <samp class="codeph">ERead</samp> requests,
data for transfer is already at the physical address. For example: </p>
 <pre class="codeblock" id="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-1B14C66A-476C-5E3F-B0D7-502B54324D74"><a name="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-1B14C66A-476C-5E3F-B0D7-502B54324D74"><!-- --></a>if (!iCurrentReq-&gt;IsPhysicalAddress())
      {
      if( (id == DMediaPagingDevice::ERomPageInRequest)||
          (id == DMediaPagingDevice::ECodePageInRequest) )
         {
         r = iCurrentReq-&gt;WriteToPageHandler((TUint8 *)(&amp; iBufPtr [0]), len, usrOfst);
         }
      else if(id==DLocalDrive::ERead)
         {
         r = iCurrentReq-&gt;WriteRemote(&amp;iBufPtr,usrOfst);
         }
      }</pre>
 <p>The same logic applies to <samp class="codeph">EWrite</samp> requests.
You need to remove calls to <a href="GUID-D84A9903-AE0F-3F54-8833-E8956A88E26C.html#GUID-D84A9903-AE0F-3F54-8833-E8956A88E26C__GUID-96B80631-AD1C-35E8-8613-0A630BD7D9E9"><span class="apiname">TLocDrvRequest::ReadRemote()</span></a>. </p>
 <p><strong>Test your changes </strong> </p>
 <p>You are recommended to run regression tests
on your changed code to makes sure that the media driver operates correctly. </p>
 </div>

<div class="section" id="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-5F4A392F-0EAF-5E69-B902-D987B8FFD610"><a name="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-5F4A392F-0EAF-5E69-B902-D987B8FFD610"><!-- --></a><h2 class="sectiontitle">Issues about
physical addresses</h2> <p>If the media driver can use physical addresses,
you need to be aware of a number of issues. </p>
 <p><strong>The address scheme used by the hardware </strong> </p>
 <p>All media devices
have a minimum number of bytes that they can transfer. For example, the architecture
of some memory card types requires data transfer in blocks of 512 bytes. To
read one byte from this type of media device, the media driver must read a
block of 512 bytes and extract the byte from the block. To write one byte
to a media device, the media driver must read a block of 512 bytes, change
the content of the byte, and write the block to the media device. </p>
 <p><strong>Data transfer smaller than the minimum size </strong> </p>
 <p>If the local
media subsystem receives a request to transfer data with a length smaller
than the minimum transfer size, the local media subsystem does not make a
physical address available to the media driver. A call to <a href="GUID-D84A9903-AE0F-3F54-8833-E8956A88E26C.html#GUID-D84A9903-AE0F-3F54-8833-E8956A88E26C__GUID-DD6773B4-9EF5-322F-B53D-29174DF3B3BF"><span class="apiname">TLocDrvRequest::IsPhysicalAddress()</span></a> returns
false. It is considered unsafe to give access to the physical data surrounding
the requested memory location. </p>
 <p><strong>Data transfer not aligned to the media device block boundary </strong> </p>
 <p>If
the local media subsystem receives a request to transfer data, and the address
on the media device is <em>not aligned</em> to the media device block boundary,
you need to adopt the technique suggested below. The local media subsystem
will make the physical address available to the media driver. A call to <a href="GUID-D84A9903-AE0F-3F54-8833-E8956A88E26C.html#GUID-D84A9903-AE0F-3F54-8833-E8956A88E26C__GUID-DD6773B4-9EF5-322F-B53D-29174DF3B3BF"><span class="apiname">TLocDrvRequest::IsPhysicalAddress()</span></a> returns
true. </p>
 <p>Consider the following case. A request has been made to read
1024 bytes from a media device that has a block size of 512 bytes. The 1024
bytes start at offset +256 on the media device. </p>
 <div class="fignone" id="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-2689C022-180B-51EF-A02D-E63ACA832EB2"><a name="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-2689C022-180B-51EF-A02D-E63ACA832EB2"><!-- --></a>
<img src="GUID-647ADEDA-AB5A-548F-93C3-D099EAE6A030_d0e409270_href.png"/>
</div>
 <p>To get the first 256 bytes, you must read the first block of 512
bytes from the media device. This can corrupt the physical memory passed in
the I/O request. The solution is to read the first block from the media device
into an intermediate buffer. Copy the 256 bytes from that buffer into the
physical memory passed in the I/O request. </p>
 <p>To get the last 256 bytes,
you must read the third block of 512 bytes from the media device into the
intermediate buffer. Copy the 256 bytes from that buffer into the correct
position in the physical memory passed in the I/O request. </p>
 <p>The middle
512 bytes are aligned on the media device block boundary. The media driver
can read this data into the correct position in the physical memory passed
in the I/O request. </p>
 <p><strong>Scatter/Gather DMA controllers </strong> </p>
 <p>DMA controllers can support
the Scatter/Gather mode of operation. Each request in this mode of operation
consists of a set of smaller requests chained together. This chain of requests
is called the Scatter/Gather list. Each item in the list consists of a physical
address and a length. </p>
 <p>Use <a href="GUID-D84A9903-AE0F-3F54-8833-E8956A88E26C.html#GUID-D84A9903-AE0F-3F54-8833-E8956A88E26C__GUID-9879145B-D996-327E-87F6-3B8337A86A56"><span class="apiname">TLocDrvRequest::GetNextPhysicalAddress()</span></a> to
help you populate the Scatter/Gather list. </p>
 <p>The following code fragment
shows how you do this. The example assumes that the DMA controller supports
a Scatter/Gather list with an unlimited number of entries. In practice, the
number of entries in the list is finite. </p>
 <pre class="codeblock" id="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-EC3A441C-080F-5EB8-B0E8-E658F80687D4"><a name="GUID-2380FDDE-5489-5B1C-87BB-1FD882E385D2__GUID-EC3A441C-080F-5EB8-B0E8-E658F80687D4"><!-- --></a>TPhysAddr physAddr; 
   TInt physLength;
   TInt err = KErrNone;

   while (iRemaining &gt; 0)
      {
      err = iCurrentReq-&gt;GetNextPhysicalAddress(physAddr, physLength);
      if(err != KErrNone)
         return err;

      iRemaining -= physLength;
      PopulateScatterGatherList(physAddr, physLength);
      }                            

   return DoDataTransfer(pos, length);</pre>
 </div>

</div>
<div>
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a href="GUID-5C223AD5-4676-58B4-B3A5-066F6B69AA4D.html" title="Provides the logical device driver for the internal and removable storage media on a phone.">Local Media Subsystem</a></div>
</div>
<div class="relinfo relconcepts"><strong>Related concepts</strong><br/>
<div><a href="GUID-86082C0C-B0EE-5E7C-85B4-4A509066012F.html" title="Describes the steps to implement a port of the MMC Controller.">MMC Porting
Implementation Tutorial</a></div>
</div>
</div>   
<p class="copyright">Copyright &#169;2010 Nokia Corporation and/or its subsidiary(-ies).<br /> All rights
reserved. Unless otherwise stated, these materials are provided under the terms of the <a href=" http://www.eclipse.org/legal/epl-v10.html"> Eclipse Public License
v1.0</a>.</p> 
</div>
</div>
<?php include_once (CURRENT_SKIN_PATH.'/sdl_footer.html'); ?>

</body>
</html>